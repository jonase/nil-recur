<html>
  <head>
    <meta charset="utf-8"/>
    <title>nil/recur</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="../css/screen.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <h1><a class="navbar-brand" href="/nil-recur/index.html">nil/recur</a></h1>
        </div>
        <!-- nav links -->
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li ><a href="/nil-recur/index.html">Home</a></li>
            <li ><a href="/nil-recur/archives.html">Archives</a></li>
            
            <li >
              <a href="/nil-recur/pages/about.html">About</a>
            </li>
            
            <li><a href="/nil-recur/feed.xml">RSS</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div id="wrapper" class="container">
      <div class="row">
        <div class="col-md-8">
          <div id="content">
            
<div id="post">
    <div id="post-header">
        <h2>Redux reducers in Clojure</h2>
        <p class="date">May 14, 2016</p>
    </div>
    <div>
        
        <p><a href='http://redux.js.org/'>Redux</a> is a Javascript library with an interesting approach to doing client side state management. It is inspired by the <a href='https://facebook.github.io/flux/docs/overview.html'>Flux architecture</a> and is most often used in combination with <a href='https://facebook.github.io/react/'>React</a>. Redux takes a very functional approach to state management which could potentially be interesting to many Clojure programmers.</p><p>At the highest level Redux works like this:</p><p><img src="img/redux01.png" alt="Redux" /></p><p>There is a single (often huge) state object which the UI uses for rendering. The UI emits actions that are fed into the reducer which together with the current state object produces the next state for the UI to render.</p><p>We know that in React the user interface is modelled as a render tree. It also often makes sense for the redux state object to be represented as some kind of tree. A more complete picture of the relation between Redux and React might look like this:</p><p><img src="img/redux02.png" alt="Redux" /></p><p>Note in particular that the shape of the state tree does not have to correspond to the shape of the render tree. It is often wise to try to keep the state tree as normalized as possible to avoid duplication. The render tree on the other hand will have a shape similar to whatever the visual design dictates.</p><p>In redux there is a single function (the reducer in the image above, sometimes called the "root" reducer for reasons that will be explained later in the post) whose job is to create new states based on all the possible actions the user interface emits. This might easily become a maintenance nightmare if not handled with care. Redux comes bundled with a function, called <code>combineReducers</code> that helps you split up the root reducer in interesting ways. The rest of this post examines this function from a Clojure point of view.</p><p>Let's start with an example. Imagine we are building some kind of email client. Our email client will manage contacts, the inbox and the emails that are sent. We will have functions for adding and removing contacts:</p><pre><code class="clojure">&#40;defn add-contact
  &#91;contacts contact&#93;
  &#40;assoc contacts &#40;:id contact&#41; contact&#41;&#41;

&#40;defn remove-contact
  &#91;contacts {:keys &#91;id&#93;}&#93;
  &#40;dissoc contacts id&#41;&#41;

&#40;-&gt; {}
    &#40;add-contact {:id 101 :email &quot;vastra@example.com&quot;}&#41;
    &#40;add-contact {:id 102 :email &quot;flint@example.com&quot;}&#41;
    &#40;add-contact {:id 103 :email &quot;strax@example.com&quot;}&#41;
    &#40;remove-contact {:id 102}&#41;&#41;

;;=&gt; {101 {:id 101, :email &quot;vastra@example.com&quot;},
;;    103 {:id 103, :email &quot;strax@example.com&quot;}}
</code></pre><p>Note that both add-contact and remove-contact could be used as reducing functions where the <code>contacts</code> argument would be the accumulator and second <code>contact</code> argument would be the next element to be ingested.</p><pre><code class="clojure">&#40;reduce add-contact
        {}
        &#91;{:id 101 :email &quot;vastra@example.com&quot;}
         {:id 102 :email &quot;flint@example.com&quot;}
         {:id 103 :email &quot;strax@example.com&quot;}&#93;&#41;

;;=&gt; {101 {:id 101, :email &quot;vastra@example.com&quot;},
;;    102 {:id 102, :email &quot;flint@example.com&quot;},
;;    103 {:id 103, :email &quot;strax@example.com&quot;}}
</code></pre><p>Let's create a single function <code>contacts-reducer</code> that combines <code>add-contact</code> and <code>remove-contact</code> into a single reducing function.</p><pre><code class="clojure">&#40;defn contacts-reducer
  &#91;contacts {:keys &#91;type payload&#93;}&#93;
  &#40;condp = type
    :add-contact &#40;add-contact contacts payload&#41;
    :remove-contact &#40;remove-contact contacts payload&#41;&#41;&#41;

&#40;reduce contacts-reducer
        {}
        &#91;{:type :add-contact
          :payload {:id 101 :email &quot;vastra@example.com&quot;}}
         {:type :add-contact
          :payload {:id 102 :email &quot;flint@example.com&quot;}}
         {:type :remove-contact
          :payload {:id 101}}
         {:type :add-contact
          :payload {:id 103 :email &quot;strax@example.com&quot;}}&#93;&#41;
;;=&gt; {102 {:id 102, :email &quot;flint@example.com&quot;},
;;    103 {:id 103, :email &quot;strax@example.com&quot;}}
</code></pre><p>Note that we use a type tag to be able to figure out which function to call. A map like</p><pre><code class="clojure">{:type :add-contact
 :payload {:id 102 :email &quot;flint@example.com&quot;}}
</code></pre><p>is called an "action" in Redux. The only requirement is the presence of the type tag. Otherwise the object can have any shape and keys. In this post I will always use the <code>:payload</code> key which will hold the data for the reducing functions.</p><p>Redux also adds a few requirements to the reducing functions themselves:</p><ul><li>If the action type is unknown, return the state unchanged.</li><li>If the state is <code>undefined</code>, return the initial state for this reducer.</li></ul><p>The <code>undefined</code> part doesn't translate well to Clojure. Instead we'll take some inspiration from <a href='http://clojure.org/reference/transducers'>transducers</a> (an eerily similar concept to Redux reducers) where the initial state is obtained by calling the reducing function without arguments.</p><p>Let's rewrite <code>contacts-reducer</code> to follow these simple rules:</p><pre><code class="clojure">&#40;defn contacts-reducer
  &#40;&#91;&#93; {}&#41;
  &#40;&#91;contacts {:keys &#91;type payload&#93;}&#93;
   &#40;condp = type
     :add-contact &#40;add-contact contacts payload&#41;
     :remove-contact &#40;remove-contact contacts payload&#41;
     contacts&#41;&#41;&#41;

&#40;contacts-reducer&#41;
;;=&gt; {}

&#40;contacts-reducer {:will &quot;not change&quot;} {:type :unknown-action}&#41;
;;=&gt; {:will &quot;not change&quot;}
</code></pre><p>To illustrate the point of Redux's <code>combineReducers</code> function we'll need a few other reducer functions as well. For managing the inbox we have:</p><pre><code class="clojure">&#40;defn add-to-inbox &#91;inbox email&#93;
  &#40;conj inbox email&#41;&#41;

&#40;defn remove-from-inbox &#91;inbox email&#93;
  &#40;disj inbox email&#41;&#41;

&#40;defn inbox-reducer
  &#40;&#91;&#93; #{}&#41;
  &#40;&#91;inbox {:keys &#91;type payload&#93;}&#93;
   &#40;condp = type
     :add-to-inbox &#40;add-to-inbox inbox payload&#41;
     :remove-from-inbox &#40;remove-from-inbox inbox payload&#41;
     inbox&#41;&#41;&#41;
</code></pre><p>The inbox is just a set of email messages. We have also defined an <code>inbox-reducer</code> that's able to add and remove emails from the inbox:</p><pre><code class="clojure">&#40;let &#91;initial-state &#40;inbox-reducer&#41;
      actions &#91;{:type :add-to-inbox
                :payload {:from &quot;vastra@example.com&quot;
		          :title &quot;Hello&quot;
			  :body &quot;...&quot;}}
               {:type :add-to-inbox
                :payload {:from &quot;flint@example.com&quot;
		          :title &quot;Lunch?&quot;
			  :body &quot;...&quot;}}
               {:type :remove-from-inbox
                :payload {:from &quot;vastra@example.com&quot;
		          :title &quot;Hello&quot;
			  :body &quot;...&quot;}}&#93;&#93;
  &#40;reduce inbox-reducer
          initial-state
          actions&#41;&#41;

;;=&gt; #{{:from &quot;flint@example.com&quot;, :title &quot;Lunch?&quot;, :body &quot;...&quot;}}
</code></pre><p>The final reducer we'll use is the one that manages the "sent" emails. We'll just handle a single action type for this reducer so we'll simply inline the implementation:</p><pre><code class="clojure">&#40;defn sent-reducer
  &#40;&#91;&#93; &#91;&#93;&#41;
  &#40;&#91;state action&#93;
   &#40;if &#40;= &#40;:type action&#41; :email-sent&#41;
     &#40;conj state &#40;:payload action&#41;&#41;
     state&#41;&#41;&#41;

&#40;let &#91;initial-state &#40;sent-reducer&#41;
      actions &#91;{:type :email-sent
                :payload {:to &quot;strax@example.com&quot;
		          :title &quot;Hi!&quot;
			  :body &quot;...&quot;}}
               {:type :email-sent
                :payload {:to &quot;vastra@example.com&quot;
		          :title &quot;Hello&quot;
			  :body &quot;...&quot;}}&#93;&#93;
  &#40;reduce sent-reducer
          initial-state
          actions&#41;&#41;

;;=&gt; &#91;{:to &quot;strax@example.com&quot;, :title &quot;Hi!&quot;, :body &quot;...&quot;}
;;    {:to &quot;vastra@example.com&quot;, :title &quot;Hello&quot;, :body &quot;...&quot;}&#93;
</code></pre><p>The Redux <code>combineReducer</code> is a higher order function that takes a map where the keys corresponds to keys in the state tree and the values are the reducers that manages that part of the state. The function returns a reducing function which is important for composability.</p><p>If we think about the state that our application will manage it could look something like</p><pre><code class="clojure">{:contacts {101 { .. first contact ..}
            102 { .. another contact ..}
	    ;; etc
	    199 { .. last contact ..}}
 :emails {:inbox #{ .. set of emails in the inbox .. }
          :sent &#91; .. list of sent emails &#93;}}
</code></pre><p>With <code>combine-reducers</code> we'll be able to create a (root) reducer that maintains the structure above and is built using the reducers we've been defining previously. Let's define the <code>root-reducer</code> using (the as of yet to be implemented) <code>combine-reducers</code>:</p><pre><code class="clojure">&#40;def root-reducer
  &#40;combine-reducers {:contacts contacts-reducer
                     :emails &#40;combine-reducers {:inbox inbox-reducer
                                                :sent sent-reducer}&#41;}&#41;&#41;
</code></pre><p>The <code>root-reducer</code> follows the same contract as the rest of the reducers:</p><pre><code class="clojure">&#40;root-reducer&#41;
;;=&gt; {:contacts {}, :emails {:inbox #{}, :sent &#91;&#93;}}


&#40;root-reducer &#40;root-reducer&#41; {:type :unknown-action}&#41;
;;=&gt; {:contacts {}, :emails {:inbox #{}, :sent &#91;&#93;}}
</code></pre><p>Note how the initial value is built using both the map structure as well as the "leaf" reducers initial values.</p><p>We can now use the <code>root-reducer</code> with all the actions we've defined</p><pre><code class="clojure">&#40;let &#91;initial-state &#40;root-reducer&#41;
      actions &#91;{:type :email-sent
                :payload {:to &quot;strax@example.com&quot;
		          :title &quot;Hi!&quot;
			  :body &quot;...&quot;}}
               {:type :add-contact
                :payload {:id 101 :email &quot;vastra@example.com&quot;}}
               {:type :add-to-inbox
                :payload {:from &quot;strax@example.com&quot;
		          :title &quot;Reply: Hi!&quot;
			  :body &quot;...&quot;}}
               {:type :add-contact
                :payload {:id 102 :email &quot;flint@example.com&quot;}}
               {:type :remove-contact
                :payload {:id 101}}
               {:type :add-contact
                :payload {:id 103 :email &quot;strax@example.com&quot;}}&#93;&#93;
  &#40;reduce root-reducer
          initial-state
          actions&#41;&#41;

;;=&gt; {:contacts {102 {:id 102, :email &quot;flint@example.com&quot;},
;;               103 {:id 103, :email &quot;strax@example.com&quot;}},
;;    :emails {:inbox #{{:from &quot;strax@example.com&quot;,
;;                       :title &quot;Reply: Hi!&quot;,
;;                       :body &quot;...&quot;}},
;;             :sent &#91;{:to &quot;strax@example.com&quot;,
;;                     :title &quot;Hi!&quot;,
;;                     :body &quot;...&quot;}&#93;}}
</code></pre><p>The implementation of <code>combine-reducer</code> looks like follows:</p><pre><code class="clojure">&#40;defn combine-reducers &#91;reducer-map&#93;
  &#40;fn
    &#40;&#91;&#93;
     &#40;reduce &#40;fn &#91;acc &#91;key reducing-fn&#93;&#93;
               &#40;assoc acc key &#40;reducing-fn&#41;&#41;&#41;
             {}
             reducer-map&#41;&#41;
    &#40;&#91;state action&#93;
     &#40;reduce &#40;fn &#91;acc &#91;key reducing-fn&#93;&#93;
               &#40;update acc key reducing-fn action&#41;&#41;
             state
             reducer-map&#41;&#41;&#41;&#41;
</code></pre><p>Note that the argument lists are the same as for all the other reducers. We build the initial value by reducing over the <code>reducer-map</code> and call the corresponding <code>reducer-fn</code> with no arguments to obtain that part of the initial value. The two argument version is also a reduction over the <code>reducer-map</code>. In this case we update the value under the key by calling what amounts to <code>&#40;reducing-fn &#40;get acc key&#41; action&#41;</code>. Note also that the top reduction uses the <code>state</code> as the initial value.</p><p>I found the <code>combine-reducers</code> function really interesting to study and reimplement in Clojure. I have not seen a similar function used in a Clojure context before.</p><p>I also find it amazing how essential functional programming has become to client side Javascript in 2016 with the rise of React and Redux (and others). I hope I've been able to show how functional programming ideas are at the very heart of how Redux works.</p>
    </div>
    
    <div id="tags">
        <b>Tags: </b>
        
        <a href="/nil-recur/tags/Redux.html">Redux</a>
        
        <a href="/nil-recur/tags/React.html">React</a>
        
        <a href="/nil-recur/tags/Clojure.html">Clojure</a>
        
    </div>
    

    <div id="prev-next">
        
        
        
        <a href="/nil-recur/posts/11-1-2015-pre-post-conditions.html">A note on pre and post conditions &raquo;</a>
        
    </div>

    


</div>

          </div>
        </div>

        <div class="col-md-3">
          <div id="sidebar">
            <h3>Links</h3>
            <ul id="links">
              <li><a href="https://github.com/jonase">My Github</a></li>
              <li><a href="https://twitter.com/jonasenlund">Twitter</a></li>
              
            </ul>
            <div id="recent">
              <h3>Recent Posts</h3>
              <ul>
                
                <li><a href="/nil-recur/posts/14-5-2016-redux-in-clojure.html">Redux reducers in Clojure</a></li>
                
                <li><a href="/nil-recur/posts/11-1-2015-pre-post-conditions.html">A note on pre and post conditions</a></li>
                
                <li><a href="/nil-recur/posts/14-12-2014-controlled-input.html">Controlled and Uncontrolled input</a></li>
                
              </ul>
            </div>
            <div id="tags">
              <h3>Tags</h3>
              <ul>
                
                <li><a href="/nil-recur/tags/test.check.html">test.check</a></li>
                
                <li><a href="/nil-recur/tags/Reagent.html">Reagent</a></li>
                
                <li><a href="/nil-recur/tags/Design by Contract.html">Design by Contract</a></li>
                
                <li><a href="/nil-recur/tags/Pre &amp; post conditions.html">Pre &amp; post conditions</a></li>
                
                <li><a href="/nil-recur/tags/requestAnimationFrame.html">requestAnimationFrame</a></li>
                
                <li><a href="/nil-recur/tags/Redux.html">Redux</a></li>
                
                <li><a href="/nil-recur/tags/Om.html">Om</a></li>
                
                <li><a href="/nil-recur/tags/React.html">React</a></li>
                
                <li><a href="/nil-recur/tags/Clojure.html">Clojure</a></li>
                
                <li><a href="/nil-recur/tags/Clojurescript.html">Clojurescript</a></li>
                
              </ul>
            </div>
          </div>
        </div>
      </div>
      <footer>Copyright &copy; 2014 Jonas Enlund
        <p style="text-align: center;">
          Powered by <a href="https://github.com/lacarmen/cryogen">Cryogen</a>
        </p>
      </footer>
    </div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="../js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-57222408-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
