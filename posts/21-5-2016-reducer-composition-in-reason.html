<html>
  <head>
    <meta charset="utf-8"/>
    <title>nil/recur</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="../css/screen.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <h1><a class="navbar-brand" href="/nil-recur/index.html">nil/recur</a></h1>
        </div>
        <!-- nav links -->
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li ><a href="/nil-recur/index.html">Home</a></li>
            <li ><a href="/nil-recur/archives.html">Archives</a></li>
            
            <li >
              <a href="/nil-recur/pages/about.html">About</a>
            </li>
            
            <li><a href="/nil-recur/feed.xml">RSS</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div id="wrapper" class="container">
      <div class="row">
        <div class="col-md-8">
          <div id="content">
            
<div id="post">
    <div id="post-header">
        <h2>Reducer composition in Reason</h2>
        <p class="date">May 21, 2016</p>
    </div>
    <div>
        
        <p><a href='http://facebook.github.io/reason/'>Reason</a> is a new syntax and set of developer tools for the <a href='https://ocaml.org/'>OCaml</a> programming language. Of all the statically typed functional languages available I've always found OCaml the most interesting. OCaml (and I hope, by extension Reason) seems to be a very pragmatic language, used in many real world situations (<a href='http://www.fftw.org/'>fftw</a>, <a href='https://mirage.io/'>mirage</a>, <a href='http://flowtype.org/'>flow</a> etc.) in a wide variety of fields. There is also really <a href='https://ocaml.org/learn/books.html'>good online learning materials</a> for beginners like myself. When Reason was released last week I couldn't wait to dig in and learn more about both Reason itself and the underlying concepts in OCaml.</p><p>A word of warning: I am not very familiar with statically typed functional programming. I've dabbled a little bit in Haskell, OCaml and Elm but never created anything substantial. Different languages often solve problems in very different ways and what I've attempted in this post might very well be something you would never do in this kind of programming language. This is a learning exercise for me and I have not much prior experience to guide me.</p><p>The problem I'm trying to solve is the same one as in my previous post (<a href='http://jonase.github.io/nil-recur/posts/14-5-2016-redux-in-clojure.html'>Redux reducers in Clojure</a>) which is a reimplementation of the <a href='http://redux.js.org/docs/api/combineReducers.html'><code>combineReducers</code></a> function from the <a href='http://redux.js.org/'>redux</a> library.</p><p>The idea is that you have a potentially large immutable <code>store</code> and a <code>reducer</code> function which, given some <code>action</code> will create a new version of the <code>store</code>.</p><p>The store can contain many different kinds of entities but often has a rigid base structure. In this example the store looks kind of like</p><pre><code class="javascript">{
  contacts: &#95;
  emails: {
    inbox: &#95;
    sent: &#95;
  }
}
</code></pre><p>There are also many different types of actions, for example</p><ul><li>Add an email to the inbox</li><li>Remove a contact</li><li>etc.</li></ul><p>To recap: There is one immutable store and one reducer function which should handle many different types of actions and route the desired update to the correct position in the store.</p><p>The challenge is to somehow build this top level reducer function out of smaller pieces in an attempt to keep things more manageable. This is solved quite elegantly in redux with its <code>combineReducer</code> higher level function. You create smaller reducer functions and combine them into the top level one:</p><pre><code class="javascript">const rootReducer = combineReducers&#40;{
  contacts: contactsReducer,
  emails: combineReducers&#40;{
    inbox: inboxReducer,
    sent: sentReducer
  }&#41;
}&#41;;
</code></pre><p>But enough with the Javascript. This post will attempt to build something similar in Reason.</p><p>In Clojure (and Javascript) you often use heterogeneous collections such as maps, vectors and sets to represent things like (in this example) contacts and emails. This has the advantage that you can jump straight to the implementation. In a statically typed language like Reason you instead invest more time in modelling and specifying the data types your program handles. The hope is that the result will be less prone to certain kinds of type related bugs. With data and function types rigourously specified the code can perhaps even be more maintainable as many design decisions are more explicit.</p><h3><a name="domain&#95;types"></a>Domain types</h3><p>A <code>contact</code> is a <a href='https://facebook.github.io/reason/#syntax-basics-records'>record</a> with an id and an email:</p><pre><code class="ocaml">type contact = {
  id: int64,
  email: string
};
</code></pre><p>We will model our contacts as an immutable <a href='https://ocaml.org/learn/tutorials/map.html'>map</a> where the id of a contact maps to the contact itself. For this we need to create a new <code>Contacts</code> module:</p><pre><code class="ocaml">let module Contacts = Map.Make Int64;
</code></pre><p>The <code>Contacts</code> module can be thought of as a map implementation specialised at handlings maps with keys of type <code>int64</code>. This module will contain all the functions we need to add/remove contacts, and of course lookup contacts by id. I find it very interesting that you need to specify the type of the key at this point, but not the value type.</p><p>An <code>email</code> is also represented as a record:</p><pre><code class="ocaml">type email = {
  from&#95;addr: string,
  to&#95;addr: string,
  title: string,
  body: string
};
</code></pre><p>For some reason I chose in the previous post to model the inbox as a set of emails. This turned out to be an excellent challenge. Records in Reason are sortable if the corresponding values are. Since all values in our email type are strings we can use the <code>compare</code> function directly:</p><pre><code class="ocaml">let email1 = {
  from&#95;addr: &quot;flint@example.com&quot;,
  to&#95;addr: &quot;strax@example.com&quot;,
  title: &quot;Hi!&quot;,
  body: &quot;...&quot;
};

let email2 = {
  from&#95;addr: &quot;strax@example.com&quot;,
  to&#95;addr: &quot;flint@example.com&quot;,
  title: &quot;Re: Hi!&quot;,
  body: &quot;...&quot;
};

compare email1 email2;
</code></pre><p>The specific sort order doesn't actually matter for our use case but it is important that <em>some</em> consistent sort order is defined for the sake of efficient set operations (for example, is a given email in the inbox or not).</p><p>To be able to create "a set of emails" we need to define an <code>Email</code> module that describes how to sort emails. If we wanted to we could define our own way of sorting at this point.</p><pre><code class="ocaml">let module Email = {
  type t = email;
  let compare = compare;
};
</code></pre><p>We can now create an <code>Inbox</code> module which will, similarly to the <code>Contacts</code> map above, contain a set implementation that can efficiently store and retrieve emails.</p><pre><code class="ocaml">let module Inbox = Set.Make Email;
</code></pre><p>We will use functions like <code>Inbox.add</code> and <code>Inbox.remove</code> later for adding/removing emails.</p><p>Finally, we will also store "sent" emails in the <code>store</code>. This will simply be represented as a linked list of emails (which has the type <code>list email</code> in Reason).</p><h3><a name="actions"></a>Actions</h3><p>Actions will also be statically typed, modelled as <a href='http://facebook.github.io/reason/#syntax-basics-variants'>variants</a> instead of records. We could have a single action type which lists all the possible actions, but I chose instead to split the actions into <code>contact&#95;action</code> and <code>inbox&#95;action</code>.</p><pre><code class="ocaml">type contact&#95;action =
  | AddContact of contact
  | RemoveContact of int64;

type inbox&#95;action =
  | AddToInbox of email
  | RemoveFromInbox of email;
</code></pre><p>These two types are composed into a top level <code>action</code> type:</p><pre><code class="ocaml">type action =
  | ContactAction of contact&#95;action
  | InboxAction of inbox&#95;action
  | EmailSentAction of email;
</code></pre><h3><a name="reducers"></a>Reducers</h3><p>A "reducing function" or "reducer" is the function that's the first argument to <code>List.fold&#95;left</code> (often called <code>reduce</code> in other languages). The reducers we will write will take some piece of the <code>store</code> as the first argument and an <code>action</code> as the second. The result will be a new <code>store</code> value with the action incorporated. Let's start with the <code>contact&#95;reducer</code>:</p><pre><code class="ocaml">let contact&#95;reducer contacts action =&gt;
  switch action {
  | ContactAction &#40;AddContact contact&#41; =&gt;
    Contacts.add contact.id contact contacts
  | ContactAction &#40;RemoveContact id&#41; =&gt;
    Contacts.remove id contacts
  | &#95; =&gt; contacts
  };
</code></pre><p>The reducer takes an action of type <code>action</code> and not the smaller type <code>contact&#95;action</code>. This is because we are modelling how reducers work in redux. The rationale is that a single action can affect many parts of the store. Say for example that the <code>contact</code> record also contained a <code>count</code> where we counted the number of interactions (sent and received emails). We could then hook into other kinds of actions, e.g. an <code>SentEmailAction</code> to be able to keep that count without creating additional <code>InboxActions</code>. Also, if the action is not handled the contacts are returned unchanged (handled byt the "wildcard" case <code>&#95; =&gt; contacts</code>).</p><p>Another requirement for reducers in redux is that if the <code>store</code> is <code>undefined</code> the reducer should return the initial value for the store. I couldn't figure out a nice way to model this so I have to cheat a bit and define the initial state of the entire store explicitly later.</p><p>The <code>inbox&#95;reducer</code> works similarly but updates <code>Inbox</code> sets instead of <code>Contacts</code> maps:</p><pre><code class="ocaml">let inbox&#95;reducer inbox action =&gt;
  switch action {
  | InboxAction ia =&gt; {
    switch ia {
    | AddToInbox email =&gt; Inbox.add email inbox
    | RemoveFromInbox email =&gt; Inbox.remove email inbox
    }
  | &#95; =&gt; inbox
  };
</code></pre><p>Previously, in <code>contacts&#95;reducer</code> we used only one switch statement to handle all the actions. For <code>inbox&#95;reducer</code> we're instead using nested switch statements to handle <code>InboxActions</code> separately. There is an advantage to this that's perhaps not immediately apparent. If we create a new kind of <code>InboxAction</code> later, and forget to handle it in the <code>inbox&#95;reducer</code> the compiler will actually be able to warn us about this potential mistake.</p><p>Finally, the <code>sent&#95;reducer</code> simply adds emails to the front of a linked list</p><pre><code class="ocaml">let sent&#95;reducer sent action =&gt;
  switch action {
  | EmailSentAction email =&gt; &#91;email, ...sent&#93;
  | &#95; =&gt; sent
  };
</code></pre><p>The store itself is modelled as nested records</p><pre><code class="ocaml">type email&#95;store = {
  inbox: Inbox.t,
  sent: list email
};

type store = {
  contacts: Contacts.t,
  emails: email&#95;store
};
</code></pre><p>Higher order reducers are combined manually until we finally define the <code>root&#95;reducer</code>:</p><pre><code class="ocaml">let email&#95;reducer email&#95;store action =&gt; {
  inbox: inbox&#95;reducer email&#95;store.inbox action,
  sent: sent&#95;reducer email&#95;store.sent action
};

let root&#95;reducer store action =&gt; {
  contacts: contact&#95;reducer store.contacts action,
  emails: email&#95;reducer store.emails action
};
</code></pre><p>To test this out we explicitly define an initial store and a list of actions</p><pre><code class="ocaml">let initial&#95;store = {
  contacts: Contacts.empty,
  emails: {
    sent: &#91;&#93;,
    inbox: Inbox.empty
  }
};

let actions = &#91;
  EmailSentAction {
    from&#95;addr: &quot;flint@example.com&quot;,
    to&#95;addr: &quot;strax@example.com&quot;,
    title: &quot;Hi!&quot;,
    body: &quot;...&quot;
  },
  ContactAction &#40;
    AddContact {id: 101L, email: &quot;vastra@example.com&quot;}
  &#41;,
  InboxAction &#40;
    AddToInbox {
      from&#95;addr: &quot;strax@example.com&quot;,
      to&#95;addr: &quot;flint@example.com&quot;,
      title: &quot;Re: Hi&quot;,
      body: &quot;...&quot;
    }
  &#41;,
  ContactAction &#40;
    AddContact {id: 102L, email: &quot;flint@example.com&quot;}
  &#41;,
  ContactAction &#40;RemoveContact 101L&#41;,
  ContactAction &#40;
    AddContact {id: 103L, email: &quot;strax@example.com&quot;}
  &#41;
&#93;;
</code></pre><p>We can load all these top level expressions into the <code>rtop</code> repl using <code>#use &quot;Reducers.re&quot;</code> or simply by copy pasting each form one by one into the repl. Finally, we can apply the list of actions to the initial store using <code>List.fold&#95;left</code> (<code>Reason#</code> is the repl prompt):</p><pre><code class="ocaml">Reason# let result = List.fold&#95;left root&#95;reducer initial&#95;store actions;
let result : store =
  {contacts : &lt;abstr&gt;,
   emails :
    {inbox : &lt;abstr&gt;,
     sent :
      &#91;{from&#95;addr : &quot;flint@example.com&quot;, to&#95;addr : &quot;strax@example.com&quot;,
        title : &quot;Hi!&quot;, body : &quot;...&quot;}&#93;}}
</code></pre><p>Unfortunately maps and sets are printed as <code>&lt;abstr&gt;</code> by the <code>rtop</code> repl but I'm just going to trust the <em>"if it compiles, it works"</em> mantra and assume it's the correct result. It is possible to tell the repl how to print custom data types, but this can be a topic for a future blog post.</p><p>For now we can also manually check contacts with</p><pre><code class="ocaml">Reason# Contacts.bindings result.contacts;
- : list &#40;int64, contact&#41; =
  &#91;&#40;102L, {id : 102L, email : &quot;flint@example.com&quot;}&#41;,
   &#40;103L, {id : 103L, email : &quot;strax@example.com&quot;}&#41;&#93;
</code></pre><p>and the inbox using</p><pre><code class="ocaml">Reason# Inbox.elements result.emails.inbox;
- : list email =
  &#91;{from&#95;addr : &quot;strax@example.com&quot;, to&#95;addr : &quot;flint@example.com&quot;,
    title : &quot;Reply: Hi&quot;, body : &quot;...&quot;}&#93;
</code></pre><h3><a name="conclusions"></a>Conclusions</h3><p>You might have noticed that I never actually defined the <code>combineReducers</code> function. This is simply because I couldn't figure out how to do it. Instead I manually built the <code>root&#95;reducer</code> out of other reducers. I'm sure it's possible to build a generic function like <code>combineReducers</code> in Reason and perhaps with more experience I'll be able to do it.</p><p>On the other hand there isn't much of a practical difference between</p><pre><code class="ocaml">let email&#95;reducer email&#95;store action =&gt; {
  inbox: inbox&#95;reducer email&#95;store.inbox action,
  sent: sent&#95;reducer email&#95;store.sent action
};

let root&#95;reducer store action =&gt; {
  contacts: contact&#95;reducer store.contacts action,
  emails: email&#95;reducer store.emails action
};
</code></pre><p>and</p><pre><code class="javascript">const rootReducer = combineReducers&#40;{
  contacts: contactsReducer,
  emails: combineReducers&#40;{
    inbox: inboxReducer,
    sent: sentReducer
  }&#41;
}&#41;;
</code></pre><p>What we achieved instead might be just as valuable since everything is type checked at compile time, including the actions and the store itself.</p><p>Finally I would like to thank <a href='https://twitter.com/pycurious'>@pycurious</a>, <a href='https://twitter.com/&#95;chenglou'>@&#95;chenglou</a>, <a href='https://twitter.com/jordwalke'>@jordwalke</a>, @jeffmo and @reynir (on irc, #reasonml) for very valuable feedback on earlier drafts of this post.</p>
    </div>
    
    <div id="tags">
        <b>Tags: </b>
        
        <a href="/nil-recur/tags/Reason.html">Reason</a>
        
    </div>
    

    <div id="prev-next">
        
        
        
        <a href="/nil-recur/posts/14-5-2016-redux-in-clojure.html">Redux reducers in Clojure &raquo;</a>
        
    </div>

    


</div>

          </div>
        </div>

        <div class="col-md-3">
          <div id="sidebar">
            <h3>Links</h3>
            <ul id="links">
              <li><a href="https://github.com/jonase">My Github</a></li>
              <li><a href="https://twitter.com/jonasenlund">Twitter</a></li>
              
            </ul>
            <div id="recent">
              <h3>Recent Posts</h3>
              <ul>
                
                <li><a href="/nil-recur/posts/21-5-2016-reducer-composition-in-reason.html">Reducer composition in Reason</a></li>
                
                <li><a href="/nil-recur/posts/14-5-2016-redux-in-clojure.html">Redux reducers in Clojure</a></li>
                
                <li><a href="/nil-recur/posts/11-1-2015-pre-post-conditions.html">A note on pre and post conditions</a></li>
                
              </ul>
            </div>
            <div id="tags">
              <h3>Tags</h3>
              <ul>
                
                <li><a href="/nil-recur/tags/test.check.html">test.check</a></li>
                
                <li><a href="/nil-recur/tags/Reagent.html">Reagent</a></li>
                
                <li><a href="/nil-recur/tags/Design by Contract.html">Design by Contract</a></li>
                
                <li><a href="/nil-recur/tags/Pre &amp; post conditions.html">Pre &amp; post conditions</a></li>
                
                <li><a href="/nil-recur/tags/requestAnimationFrame.html">requestAnimationFrame</a></li>
                
                <li><a href="/nil-recur/tags/Redux.html">Redux</a></li>
                
                <li><a href="/nil-recur/tags/Om.html">Om</a></li>
                
                <li><a href="/nil-recur/tags/React.html">React</a></li>
                
                <li><a href="/nil-recur/tags/Clojure.html">Clojure</a></li>
                
                <li><a href="/nil-recur/tags/Clojurescript.html">Clojurescript</a></li>
                
                <li><a href="/nil-recur/tags/Reason.html">Reason</a></li>
                
              </ul>
            </div>
          </div>
        </div>
      </div>
      <footer>Copyright &copy; 2014 Jonas Enlund
        <p style="text-align: center;">
          Powered by <a href="https://github.com/lacarmen/cryogen">Cryogen</a>
        </p>
      </footer>
    </div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="../js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-57222408-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
