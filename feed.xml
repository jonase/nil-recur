<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://jonase.github.io' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
nil/recur
</title>
<link>
http://jonase.github.io
</link>
<description>
Ramblings about programming
</description>
<lastBuildDate>
Wed, 25 May 2016 17:49:06 +0300
</lastBuildDate>
<author>
Jonas Enlund
</author>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/21-5-2016-reducer-composition-in-reason.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/21-5-2016-reducer-composition-in-reason.html
</link>
<title>
Reducer composition in Reason
</title>
<description>
&lt;p&gt;&lt;a href='http://facebook.github.io/reason/'&gt;Reason&lt;/a&gt; is a new syntax and set of developer tools for the &lt;a href='https://ocaml.org/'&gt;OCaml&lt;/a&gt; programming language. Of all the statically typed functional languages available I've always found OCaml the most interesting. OCaml (and I hope, by extension Reason) seems to be a very pragmatic language, used in many real world situations (&lt;a href='http://www.fftw.org/'&gt;fftw&lt;/a&gt;, &lt;a href='https://mirage.io/'&gt;mirage&lt;/a&gt;, &lt;a href='http://flowtype.org/'&gt;flow&lt;/a&gt; etc.) in a wide variety of fields. There is also really &lt;a href='https://ocaml.org/learn/books.html'&gt;good online learning materials&lt;/a&gt; for beginners like myself. When Reason was released last week I couldn't wait to dig in and learn more about both Reason itself and the underlying concepts in OCaml.&lt;/p&gt;&lt;p&gt;A word of warning: I am not very familiar with statically typed functional programming. I've dabbled a little bit in Haskell, OCaml and Elm but never created anything substantial. Different languages often solve problems in very different ways and what I've attempted in this post might very well be something you would never do in this kind of programming language. This is a learning exercise for me and I have not much prior experience to guide me.&lt;/p&gt;&lt;p&gt;The problem I'm trying to solve is the same one as in my previous post (&lt;a href='http://jonase.github.io/nil-recur/posts/14-5-2016-redux-in-clojure.html'&gt;Redux reducers in Clojure&lt;/a&gt;) which is a reimplementation of the &lt;a href='http://redux.js.org/docs/api/combineReducers.html'&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; function from the &lt;a href='http://redux.js.org/'&gt;redux&lt;/a&gt; library.&lt;/p&gt;&lt;p&gt;The idea is that you have a potentially large immutable &lt;code&gt;store&lt;/code&gt; and a &lt;code&gt;reducer&lt;/code&gt; function which, given some &lt;code&gt;action&lt;/code&gt; will create a new version of the &lt;code&gt;store&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The store can contain many different kinds of entities but often has a rigid base structure. In this example the store looks kind of like&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;{
  contacts: &amp;#95;
  emails: {
    inbox: &amp;#95;
    sent: &amp;#95;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also many different types of actions, for example&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Add an email to the inbox&lt;/li&gt;&lt;li&gt;Remove a contact&lt;/li&gt;&lt;li&gt;etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To recap: There is one immutable store and one reducer function which should handle many different types of actions and route the desired update to the correct position in the store.&lt;/p&gt;&lt;p&gt;The challenge is to somehow build this top level reducer function out of smaller pieces in an attempt to keep things more manageable. This is solved quite elegantly in redux with its &lt;code&gt;combineReducer&lt;/code&gt; higher level function. You create smaller reducer functions and combine them into the top level one:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const rootReducer = combineReducers&amp;#40;{
  contacts: contactsReducer,
  emails: combineReducers&amp;#40;{
    inbox: inboxReducer,
    sent: sentReducer
  }&amp;#41;
}&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But enough with the Javascript. This post will attempt to build something similar in Reason.&lt;/p&gt;&lt;p&gt;In Clojure (and Javascript) you often use heterogeneous collections such as maps, vectors and sets to represent things like (in this example) contacts and emails. This has the advantage that you can jump straight to the implementation. In a statically typed language like Reason you instead invest more time in modelling and specifying the data types your program handles. The hope is that the result will be less prone to certain kinds of type related bugs. With data and function types rigourously specified the code can perhaps even be more maintainable as many design decisions are more explicit.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;domain&amp;#95;types&quot;&gt;&lt;/a&gt;Domain types&lt;/h3&gt;&lt;p&gt;A &lt;code&gt;contact&lt;/code&gt; is a &lt;a href='https://facebook.github.io/reason/#syntax-basics-records'&gt;record&lt;/a&gt; with an id and an email:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type contact = {
  id: int64,
  email: string
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will model our contacts as an immutable &lt;a href='https://ocaml.org/learn/tutorials/map.html'&gt;map&lt;/a&gt; where the id of a contact maps to the contact itself. For this we need to create a new &lt;code&gt;Contacts&lt;/code&gt; module:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let module Contacts = Map.Make Int64;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;Contacts&lt;/code&gt; module can be thought of as a map implementation specialised at handlings maps with keys of type &lt;code&gt;int64&lt;/code&gt;. This module will contain all the functions we need to add/remove contacts, and of course lookup contacts by id. I find it very interesting that you need to specify the type of the key at this point, but not the value type.&lt;/p&gt;&lt;p&gt;An &lt;code&gt;email&lt;/code&gt; is also represented as a record:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type email = {
  from&amp;#95;addr: string,
  to&amp;#95;addr: string,
  title: string,
  body: string
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For some reason I chose in the previous post to model the inbox as a set of emails. This turned out to be an excellent challenge. Records in Reason are sortable if the corresponding values are. Since all values in our email type are strings we can use the &lt;code&gt;compare&lt;/code&gt; function directly:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let email1 = {
  from&amp;#95;addr: &amp;quot;flint@example.com&amp;quot;,
  to&amp;#95;addr: &amp;quot;strax@example.com&amp;quot;,
  title: &amp;quot;Hi!&amp;quot;,
  body: &amp;quot;...&amp;quot;
};

let email2 = {
  from&amp;#95;addr: &amp;quot;strax@example.com&amp;quot;,
  to&amp;#95;addr: &amp;quot;flint@example.com&amp;quot;,
  title: &amp;quot;Re: Hi!&amp;quot;,
  body: &amp;quot;...&amp;quot;
};

compare email1 email2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The specific sort order doesn't actually matter for our use case but it is important that &lt;em&gt;some&lt;/em&gt; consistent sort order is defined for the sake of efficient set operations (for example, is a given email in the inbox or not).&lt;/p&gt;&lt;p&gt;To be able to create &quot;a set of emails&quot; we need to define an &lt;code&gt;Email&lt;/code&gt; module that describes how to sort emails. If we wanted to we could define our own way of sorting at this point.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let module Email = {
  type t = email;
  let compare = compare;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now create an &lt;code&gt;Inbox&lt;/code&gt; module which will, similarly to the &lt;code&gt;Contacts&lt;/code&gt; map above, contain a set implementation that can efficiently store and retrieve emails.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let module Inbox = Set.Make Email;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will use functions like &lt;code&gt;Inbox.add&lt;/code&gt; and &lt;code&gt;Inbox.remove&lt;/code&gt; later for adding/removing emails.&lt;/p&gt;&lt;p&gt;Finally, we will also store &quot;sent&quot; emails in the &lt;code&gt;store&lt;/code&gt;. This will simply be represented as a linked list of emails (which has the type &lt;code&gt;list email&lt;/code&gt; in Reason).&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;actions&quot;&gt;&lt;/a&gt;Actions&lt;/h3&gt;&lt;p&gt;Actions will also be statically typed, modelled as &lt;a href='http://facebook.github.io/reason/#syntax-basics-variants'&gt;variants&lt;/a&gt; instead of records. We could have a single action type which lists all the possible actions, but I chose instead to split the actions into &lt;code&gt;contact&amp;#95;action&lt;/code&gt; and &lt;code&gt;inbox&amp;#95;action&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type contact&amp;#95;action =
  | AddContact of contact
  | RemoveContact of int64;

type inbox&amp;#95;action =
  | AddToInbox of email
  | RemoveFromInbox of email;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two types are composed into a top level &lt;code&gt;action&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type action =
  | ContactAction of contact&amp;#95;action
  | InboxAction of inbox&amp;#95;action
  | EmailSentAction of email;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;reducers&quot;&gt;&lt;/a&gt;Reducers&lt;/h3&gt;&lt;p&gt;A &quot;reducing function&quot; or &quot;reducer&quot; is the function that's the first argument to &lt;code&gt;List.fold&amp;#95;left&lt;/code&gt; (often called &lt;code&gt;reduce&lt;/code&gt; in other languages). The reducers we will write will take some piece of the &lt;code&gt;store&lt;/code&gt; as the first argument and an &lt;code&gt;action&lt;/code&gt; as the second. The result will be a new &lt;code&gt;store&lt;/code&gt; value with the action incorporated. Let's start with the &lt;code&gt;contact&amp;#95;reducer&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let contact&amp;#95;reducer contacts action =&amp;gt;
  switch action {
  | ContactAction &amp;#40;AddContact contact&amp;#41; =&amp;gt;
    Contacts.add contact.id contact contacts
  | ContactAction &amp;#40;RemoveContact id&amp;#41; =&amp;gt;
    Contacts.remove id contacts
  | &amp;#95; =&amp;gt; contacts
  };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reducer takes an action of type &lt;code&gt;action&lt;/code&gt; and not the smaller type &lt;code&gt;contact&amp;#95;action&lt;/code&gt;. This is because we are modelling how reducers work in redux. The rationale is that a single action can affect many parts of the store. Say for example that the &lt;code&gt;contact&lt;/code&gt; record also contained a &lt;code&gt;count&lt;/code&gt; where we counted the number of interactions (sent and received emails). We could then hook into other kinds of actions, e.g. an &lt;code&gt;SentEmailAction&lt;/code&gt; to be able to keep that count without creating additional &lt;code&gt;InboxActions&lt;/code&gt;. Also, if the action is not handled the contacts are returned unchanged (handled byt the &quot;wildcard&quot; case &lt;code&gt;&amp;#95; =&amp;gt; contacts&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;Another requirement for reducers in redux is that if the &lt;code&gt;store&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; the reducer should return the initial value for the store. I couldn't figure out a nice way to model this so I have to cheat a bit and define the initial state of the entire store explicitly later.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;inbox&amp;#95;reducer&lt;/code&gt; works similarly but updates &lt;code&gt;Inbox&lt;/code&gt; sets instead of &lt;code&gt;Contacts&lt;/code&gt; maps:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let inbox&amp;#95;reducer inbox action =&amp;gt;
  switch action {
  | InboxAction ia =&amp;gt; {
    switch ia {
    | AddToInbox email =&amp;gt; Inbox.add email inbox
    | RemoveFromInbox email =&amp;gt; Inbox.remove email inbox
    }
  | &amp;#95; =&amp;gt; inbox
  };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Previously, in &lt;code&gt;contacts&amp;#95;reducer&lt;/code&gt; we used only one switch statement to handle all the actions. For &lt;code&gt;inbox&amp;#95;reducer&lt;/code&gt; we're instead using nested switch statements to handle &lt;code&gt;InboxActions&lt;/code&gt; separately. There is an advantage to this that's perhaps not immediately apparent. If we create a new kind of &lt;code&gt;InboxAction&lt;/code&gt; later, and forget to handle it in the &lt;code&gt;inbox&amp;#95;reducer&lt;/code&gt; the compiler will actually be able to warn us about this potential mistake.&lt;/p&gt;&lt;p&gt;Finally, the &lt;code&gt;sent&amp;#95;reducer&lt;/code&gt; simply adds emails to the front of a linked list&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let sent&amp;#95;reducer sent action =&amp;gt;
  switch action {
  | EmailSentAction email =&amp;gt; &amp;#91;email, ...sent&amp;#93;
  | &amp;#95; =&amp;gt; sent
  };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The store itself is modelled as nested records&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type email&amp;#95;store = {
  inbox: Inbox.t,
  sent: list email
};

type store = {
  contacts: Contacts.t,
  emails: email&amp;#95;store
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Higher order reducers are combined manually until we finally define the &lt;code&gt;root&amp;#95;reducer&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let email&amp;#95;reducer email&amp;#95;store action =&amp;gt; {
  inbox: inbox&amp;#95;reducer email&amp;#95;store.inbox action,
  sent: sent&amp;#95;reducer email&amp;#95;store.sent action
};

let root&amp;#95;reducer store action =&amp;gt; {
  contacts: contact&amp;#95;reducer store.contacts action,
  emails: email&amp;#95;reducer store.emails action
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To test this out we explicitly define an initial store and a list of actions&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let initial&amp;#95;store = {
  contacts: Contacts.empty,
  emails: {
    sent: &amp;#91;&amp;#93;,
    inbox: Inbox.empty
  }
};

let actions = &amp;#91;
  EmailSentAction {
    from&amp;#95;addr: &amp;quot;flint@example.com&amp;quot;,
    to&amp;#95;addr: &amp;quot;strax@example.com&amp;quot;,
    title: &amp;quot;Hi!&amp;quot;,
    body: &amp;quot;...&amp;quot;
  },
  ContactAction &amp;#40;
    AddContact {id: 101L, email: &amp;quot;vastra@example.com&amp;quot;}
  &amp;#41;,
  InboxAction &amp;#40;
    AddToInbox {
      from&amp;#95;addr: &amp;quot;strax@example.com&amp;quot;,
      to&amp;#95;addr: &amp;quot;flint@example.com&amp;quot;,
      title: &amp;quot;Re: Hi&amp;quot;,
      body: &amp;quot;...&amp;quot;
    }
  &amp;#41;,
  ContactAction &amp;#40;
    AddContact {id: 102L, email: &amp;quot;flint@example.com&amp;quot;}
  &amp;#41;,
  ContactAction &amp;#40;RemoveContact 101L&amp;#41;,
  ContactAction &amp;#40;
    AddContact {id: 103L, email: &amp;quot;strax@example.com&amp;quot;}
  &amp;#41;
&amp;#93;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can load all these top level expressions into the &lt;code&gt;rtop&lt;/code&gt; repl using &lt;code&gt;#use &amp;quot;Reducers.re&amp;quot;&lt;/code&gt; or simply by copy pasting each form one by one into the repl. Finally, we can apply the list of actions to the initial store using &lt;code&gt;List.fold&amp;#95;left&lt;/code&gt; (&lt;code&gt;Reason#&lt;/code&gt; is the repl prompt):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;Reason# let result = List.fold&amp;#95;left root&amp;#95;reducer initial&amp;#95;store actions;
let result : store =
  {contacts : &amp;lt;abstr&amp;gt;,
   emails :
    {inbox : &amp;lt;abstr&amp;gt;,
     sent :
      &amp;#91;{from&amp;#95;addr : &amp;quot;flint@example.com&amp;quot;, to&amp;#95;addr : &amp;quot;strax@example.com&amp;quot;,
        title : &amp;quot;Hi!&amp;quot;, body : &amp;quot;...&amp;quot;}&amp;#93;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unfortunately maps and sets are printed as &lt;code&gt;&amp;lt;abstr&amp;gt;&lt;/code&gt; by the &lt;code&gt;rtop&lt;/code&gt; repl but I'm just going to trust the &lt;em&gt;&quot;if it compiles, it works&quot;&lt;/em&gt; mantra and assume it's the correct result. It is possible to tell the repl how to print custom data types, but this can be a topic for a future blog post.&lt;/p&gt;&lt;p&gt;For now we can also manually check contacts with&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;Reason# Contacts.bindings result.contacts;
- : list &amp;#40;int64, contact&amp;#41; =
  &amp;#91;&amp;#40;102L, {id : 102L, email : &amp;quot;flint@example.com&amp;quot;}&amp;#41;,
   &amp;#40;103L, {id : 103L, email : &amp;quot;strax@example.com&amp;quot;}&amp;#41;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and the inbox using&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;Reason# Inbox.elements result.emails.inbox;
- : list email =
  &amp;#91;{from&amp;#95;addr : &amp;quot;strax@example.com&amp;quot;, to&amp;#95;addr : &amp;quot;flint@example.com&amp;quot;,
    title : &amp;quot;Reply: Hi&amp;quot;, body : &amp;quot;...&amp;quot;}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;conclusions&quot;&gt;&lt;/a&gt;Conclusions&lt;/h3&gt;&lt;p&gt;You might have noticed that I never actually defined the &lt;code&gt;combineReducers&lt;/code&gt; function. This is simply because I couldn't figure out how to do it. Instead I manually built the &lt;code&gt;root&amp;#95;reducer&lt;/code&gt; out of other reducers. I'm sure it's possible to build a generic function like &lt;code&gt;combineReducers&lt;/code&gt; in Reason and perhaps with more experience I'll be able to do it.&lt;/p&gt;&lt;p&gt;On the other hand there isn't much of a practical difference between&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let email&amp;#95;reducer email&amp;#95;store action =&amp;gt; {
  inbox: inbox&amp;#95;reducer email&amp;#95;store.inbox action,
  sent: sent&amp;#95;reducer email&amp;#95;store.sent action
};

let root&amp;#95;reducer store action =&amp;gt; {
  contacts: contact&amp;#95;reducer store.contacts action,
  emails: email&amp;#95;reducer store.emails action
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const rootReducer = combineReducers&amp;#40;{
  contacts: contactsReducer,
  emails: combineReducers&amp;#40;{
    inbox: inboxReducer,
    sent: sentReducer
  }&amp;#41;
}&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What we achieved instead might be just as valuable since everything is type checked at compile time, including the actions and the store itself.&lt;/p&gt;&lt;p&gt;Finally I would like to thank &lt;a href='https://twitter.com/pycurious'&gt;@pycurious&lt;/a&gt;, &lt;a href='https://twitter.com/&amp;#95;chenglou'&gt;@&amp;#95;chenglou&lt;/a&gt;, &lt;a href='https://twitter.com/jordwalke'&gt;@jordwalke&lt;/a&gt;, @jeffmo and @reynir (on irc, #reasonml) for very valuable feedback on earlier drafts of this post.&lt;/p&gt;
</description>
<pubDate>
Sat, 21 May 2016 00:00:00 +0300
</pubDate>
<author>
Jonas Enlund
</author>
</item>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/14-5-2016-redux-in-clojure.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/14-5-2016-redux-in-clojure.html
</link>
<title>
Redux reducers in Clojure
</title>
<description>
&lt;p&gt;&lt;a href='http://redux.js.org/'&gt;Redux&lt;/a&gt; is a Javascript library with an interesting approach to doing client side state management. It is inspired by the &lt;a href='https://facebook.github.io/flux/docs/overview.html'&gt;Flux architecture&lt;/a&gt; and is most often used in combination with &lt;a href='https://facebook.github.io/react/'&gt;React&lt;/a&gt;. Redux takes a very functional approach to state management which could potentially be interesting to many Clojure programmers.&lt;/p&gt;&lt;p&gt;At the highest level Redux works like this:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/nil-recur/img/redux01.png&quot; alt=&quot;Redux&quot; /&gt;&lt;/p&gt;&lt;p&gt;There is a single (often huge) state object which the UI uses for rendering. The UI emits actions that are fed into the reducer which together with the current state object produces the next state for the UI to render.&lt;/p&gt;&lt;p&gt;We know that in React the user interface is modelled as a render tree. It also often makes sense for the redux state object to be represented as some kind of tree. A more complete picture of the relation between Redux and React might look like this:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/nil-recur/img/redux02.png&quot; alt=&quot;Redux&quot; /&gt;&lt;/p&gt;&lt;p&gt;Note in particular that the shape of the state tree does not have to correspond to the shape of the render tree. It is often wise to try to keep the state tree as normalized as possible to avoid duplication. The render tree on the other hand will have a shape similar to whatever the visual design dictates.&lt;/p&gt;&lt;p&gt;In redux there is a single function (the reducer in the image above, sometimes called the &quot;root&quot; reducer for reasons that will be explained later in the post) whose job is to create new states based on all the possible actions the user interface emits. This might easily become a maintenance nightmare if not handled with care. Redux comes bundled with a function, called &lt;code&gt;combineReducers&lt;/code&gt; that helps you split up the root reducer in interesting ways. The rest of this post examines this function from a Clojure point of view.&lt;/p&gt;&lt;p&gt;Let's start with an example. Imagine we are building some kind of email client. Our email client will manage contacts, the inbox and the emails that are sent. We will have functions for adding and removing contacts:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn add-contact
  &amp;#91;contacts contact&amp;#93;
  &amp;#40;assoc contacts &amp;#40;:id contact&amp;#41; contact&amp;#41;&amp;#41;

&amp;#40;defn remove-contact
  &amp;#91;contacts {:keys &amp;#91;id&amp;#93;}&amp;#93;
  &amp;#40;dissoc contacts id&amp;#41;&amp;#41;

&amp;#40;-&amp;gt; {}
    &amp;#40;add-contact {:id 101 :email &amp;quot;vastra@example.com&amp;quot;}&amp;#41;
    &amp;#40;add-contact {:id 102 :email &amp;quot;flint@example.com&amp;quot;}&amp;#41;
    &amp;#40;add-contact {:id 103 :email &amp;quot;strax@example.com&amp;quot;}&amp;#41;
    &amp;#40;remove-contact {:id 102}&amp;#41;&amp;#41;

;;=&amp;gt; {101 {:id 101, :email &amp;quot;vastra@example.com&amp;quot;},
;;    103 {:id 103, :email &amp;quot;strax@example.com&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that both add-contact and remove-contact could be used as reducing functions where the &lt;code&gt;contacts&lt;/code&gt; argument would be the accumulator and second &lt;code&gt;contact&lt;/code&gt; argument would be the next element to be ingested.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;reduce add-contact
        {}
        &amp;#91;{:id 101 :email &amp;quot;vastra@example.com&amp;quot;}
         {:id 102 :email &amp;quot;flint@example.com&amp;quot;}
         {:id 103 :email &amp;quot;strax@example.com&amp;quot;}&amp;#93;&amp;#41;

;;=&amp;gt; {101 {:id 101, :email &amp;quot;vastra@example.com&amp;quot;},
;;    102 {:id 102, :email &amp;quot;flint@example.com&amp;quot;},
;;    103 {:id 103, :email &amp;quot;strax@example.com&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's create a single function &lt;code&gt;contacts-reducer&lt;/code&gt; that combines &lt;code&gt;add-contact&lt;/code&gt; and &lt;code&gt;remove-contact&lt;/code&gt; into a single reducing function.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn contacts-reducer
  &amp;#91;contacts {:keys &amp;#91;type payload&amp;#93;}&amp;#93;
  &amp;#40;condp = type
    :add-contact &amp;#40;add-contact contacts payload&amp;#41;
    :remove-contact &amp;#40;remove-contact contacts payload&amp;#41;&amp;#41;&amp;#41;

&amp;#40;reduce contacts-reducer
        {}
        &amp;#91;{:type :add-contact
          :payload {:id 101 :email &amp;quot;vastra@example.com&amp;quot;}}
         {:type :add-contact
          :payload {:id 102 :email &amp;quot;flint@example.com&amp;quot;}}
         {:type :remove-contact
          :payload {:id 101}}
         {:type :add-contact
          :payload {:id 103 :email &amp;quot;strax@example.com&amp;quot;}}&amp;#93;&amp;#41;
;;=&amp;gt; {102 {:id 102, :email &amp;quot;flint@example.com&amp;quot;},
;;    103 {:id 103, :email &amp;quot;strax@example.com&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that we use a type tag to be able to figure out which function to call. A map like&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:type :add-contact
 :payload {:id 102 :email &amp;quot;flint@example.com&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is called an &quot;action&quot; in Redux. The only requirement is the presence of the type tag. Otherwise the object can have any shape and keys. In this post I will always use the &lt;code&gt;:payload&lt;/code&gt; key which will hold the data for the reducing functions.&lt;/p&gt;&lt;p&gt;Redux also adds a few requirements to the reducing functions themselves:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;If the action type is unknown, return the state unchanged.&lt;/li&gt;&lt;li&gt;If the state is &lt;code&gt;undefined&lt;/code&gt;, return the initial state for this reducer.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;code&gt;undefined&lt;/code&gt; part doesn't translate well to Clojure. Instead we'll take some inspiration from &lt;a href='http://clojure.org/reference/transducers'&gt;transducers&lt;/a&gt; (an eerily similar concept to Redux reducers) where the initial state is obtained by calling the reducing function without arguments.&lt;/p&gt;&lt;p&gt;Let's rewrite &lt;code&gt;contacts-reducer&lt;/code&gt; to follow these simple rules:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn contacts-reducer
  &amp;#40;&amp;#91;&amp;#93; {}&amp;#41;
  &amp;#40;&amp;#91;contacts {:keys &amp;#91;type payload&amp;#93;}&amp;#93;
   &amp;#40;condp = type
     :add-contact &amp;#40;add-contact contacts payload&amp;#41;
     :remove-contact &amp;#40;remove-contact contacts payload&amp;#41;
     contacts&amp;#41;&amp;#41;&amp;#41;

&amp;#40;contacts-reducer&amp;#41;
;;=&amp;gt; {}

&amp;#40;contacts-reducer {:will &amp;quot;not change&amp;quot;} {:type :unknown-action}&amp;#41;
;;=&amp;gt; {:will &amp;quot;not change&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To illustrate the point of Redux's &lt;code&gt;combineReducers&lt;/code&gt; function we'll need a few other reducer functions as well. For managing the inbox we have:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn add-to-inbox &amp;#91;inbox email&amp;#93;
  &amp;#40;conj inbox email&amp;#41;&amp;#41;

&amp;#40;defn remove-from-inbox &amp;#91;inbox email&amp;#93;
  &amp;#40;disj inbox email&amp;#41;&amp;#41;

&amp;#40;defn inbox-reducer
  &amp;#40;&amp;#91;&amp;#93; #{}&amp;#41;
  &amp;#40;&amp;#91;inbox {:keys &amp;#91;type payload&amp;#93;}&amp;#93;
   &amp;#40;condp = type
     :add-to-inbox &amp;#40;add-to-inbox inbox payload&amp;#41;
     :remove-from-inbox &amp;#40;remove-from-inbox inbox payload&amp;#41;
     inbox&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The inbox is just a set of email messages. We have also defined an &lt;code&gt;inbox-reducer&lt;/code&gt; that's able to add and remove emails from the inbox:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;let &amp;#91;initial-state &amp;#40;inbox-reducer&amp;#41;
      actions &amp;#91;{:type :add-to-inbox
                :payload {:from &amp;quot;vastra@example.com&amp;quot;
		          :title &amp;quot;Hello&amp;quot;
			  :body &amp;quot;...&amp;quot;}}
               {:type :add-to-inbox
                :payload {:from &amp;quot;flint@example.com&amp;quot;
		          :title &amp;quot;Lunch?&amp;quot;
			  :body &amp;quot;...&amp;quot;}}
               {:type :remove-from-inbox
                :payload {:from &amp;quot;vastra@example.com&amp;quot;
		          :title &amp;quot;Hello&amp;quot;
			  :body &amp;quot;...&amp;quot;}}&amp;#93;&amp;#93;
  &amp;#40;reduce inbox-reducer
          initial-state
          actions&amp;#41;&amp;#41;

;;=&amp;gt; #{{:from &amp;quot;flint@example.com&amp;quot;, :title &amp;quot;Lunch?&amp;quot;, :body &amp;quot;...&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The final reducer we'll use is the one that manages the &quot;sent&quot; emails. We'll just handle a single action type for this reducer so we'll simply inline the implementation:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn sent-reducer
  &amp;#40;&amp;#91;&amp;#93; &amp;#91;&amp;#93;&amp;#41;
  &amp;#40;&amp;#91;state action&amp;#93;
   &amp;#40;if &amp;#40;= &amp;#40;:type action&amp;#41; :email-sent&amp;#41;
     &amp;#40;conj state &amp;#40;:payload action&amp;#41;&amp;#41;
     state&amp;#41;&amp;#41;&amp;#41;

&amp;#40;let &amp;#91;initial-state &amp;#40;sent-reducer&amp;#41;
      actions &amp;#91;{:type :email-sent
                :payload {:to &amp;quot;strax@example.com&amp;quot;
		          :title &amp;quot;Hi!&amp;quot;
			  :body &amp;quot;...&amp;quot;}}
               {:type :email-sent
                :payload {:to &amp;quot;vastra@example.com&amp;quot;
		          :title &amp;quot;Hello&amp;quot;
			  :body &amp;quot;...&amp;quot;}}&amp;#93;&amp;#93;
  &amp;#40;reduce sent-reducer
          initial-state
          actions&amp;#41;&amp;#41;

;;=&amp;gt; &amp;#91;{:to &amp;quot;strax@example.com&amp;quot;, :title &amp;quot;Hi!&amp;quot;, :body &amp;quot;...&amp;quot;}
;;    {:to &amp;quot;vastra@example.com&amp;quot;, :title &amp;quot;Hello&amp;quot;, :body &amp;quot;...&amp;quot;}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Redux &lt;code&gt;combineReducer&lt;/code&gt; is a higher order function that takes a map where the keys corresponds to keys in the state tree and the values are the reducers that manages that part of the state. The function returns a reducing function which is important for composability.&lt;/p&gt;&lt;p&gt;If we think about the state that our application will manage it could look something like&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:contacts {101 { .. first contact ..}
            102 { .. another contact ..}
	    ;; etc
	    199 { .. last contact ..}}
 :emails {:inbox #{ .. set of emails in the inbox .. }
          :sent &amp;#91; .. list of sent emails &amp;#93;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With &lt;code&gt;combine-reducers&lt;/code&gt; we'll be able to create a (root) reducer that maintains the structure above and is built using the reducers we've been defining previously. Let's define the &lt;code&gt;root-reducer&lt;/code&gt; using (the as of yet to be implemented) &lt;code&gt;combine-reducers&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def root-reducer
  &amp;#40;combine-reducers {:contacts contacts-reducer
                     :emails &amp;#40;combine-reducers {:inbox inbox-reducer
                                                :sent sent-reducer}&amp;#41;}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;root-reducer&lt;/code&gt; follows the same contract as the rest of the reducers:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;root-reducer&amp;#41;
;;=&amp;gt; {:contacts {}, :emails {:inbox #{}, :sent &amp;#91;&amp;#93;}}


&amp;#40;root-reducer &amp;#40;root-reducer&amp;#41; {:type :unknown-action}&amp;#41;
;;=&amp;gt; {:contacts {}, :emails {:inbox #{}, :sent &amp;#91;&amp;#93;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note how the initial value is built using both the map structure as well as the &quot;leaf&quot; reducers initial values.&lt;/p&gt;&lt;p&gt;We can now use the &lt;code&gt;root-reducer&lt;/code&gt; with all the actions we've defined&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;let &amp;#91;initial-state &amp;#40;root-reducer&amp;#41;
      actions &amp;#91;{:type :email-sent
                :payload {:to &amp;quot;strax@example.com&amp;quot;
		          :title &amp;quot;Hi!&amp;quot;
			  :body &amp;quot;...&amp;quot;}}
               {:type :add-contact
                :payload {:id 101 :email &amp;quot;vastra@example.com&amp;quot;}}
               {:type :add-to-inbox
                :payload {:from &amp;quot;strax@example.com&amp;quot;
		          :title &amp;quot;Reply: Hi!&amp;quot;
			  :body &amp;quot;...&amp;quot;}}
               {:type :add-contact
                :payload {:id 102 :email &amp;quot;flint@example.com&amp;quot;}}
               {:type :remove-contact
                :payload {:id 101}}
               {:type :add-contact
                :payload {:id 103 :email &amp;quot;strax@example.com&amp;quot;}}&amp;#93;&amp;#93;
  &amp;#40;reduce root-reducer
          initial-state
          actions&amp;#41;&amp;#41;

;;=&amp;gt; {:contacts {102 {:id 102, :email &amp;quot;flint@example.com&amp;quot;},
;;               103 {:id 103, :email &amp;quot;strax@example.com&amp;quot;}},
;;    :emails {:inbox #{{:from &amp;quot;strax@example.com&amp;quot;,
;;                       :title &amp;quot;Reply: Hi!&amp;quot;,
;;                       :body &amp;quot;...&amp;quot;}},
;;             :sent &amp;#91;{:to &amp;quot;strax@example.com&amp;quot;,
;;                     :title &amp;quot;Hi!&amp;quot;,
;;                     :body &amp;quot;...&amp;quot;}&amp;#93;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The implementation of &lt;code&gt;combine-reducer&lt;/code&gt; looks like follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn combine-reducers &amp;#91;reducer-map&amp;#93;
  &amp;#40;fn
    &amp;#40;&amp;#91;&amp;#93;
     &amp;#40;reduce &amp;#40;fn &amp;#91;acc &amp;#91;key reducing-fn&amp;#93;&amp;#93;
               &amp;#40;assoc acc key &amp;#40;reducing-fn&amp;#41;&amp;#41;&amp;#41;
             {}
             reducer-map&amp;#41;&amp;#41;
    &amp;#40;&amp;#91;state action&amp;#93;
     &amp;#40;reduce &amp;#40;fn &amp;#91;acc &amp;#91;key reducing-fn&amp;#93;&amp;#93;
               &amp;#40;update acc key reducing-fn action&amp;#41;&amp;#41;
             state
             reducer-map&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the argument lists are the same as for all the other reducers. We build the initial value by reducing over the &lt;code&gt;reducer-map&lt;/code&gt; and call the corresponding &lt;code&gt;reducer-fn&lt;/code&gt; with no arguments to obtain that part of the initial value. The two argument version is also a reduction over the &lt;code&gt;reducer-map&lt;/code&gt;. In this case we update the value under the key by calling what amounts to &lt;code&gt;&amp;#40;reducing-fn &amp;#40;get acc key&amp;#41; action&amp;#41;&lt;/code&gt;. Note also that the top reduction uses the &lt;code&gt;state&lt;/code&gt; as the initial value.&lt;/p&gt;&lt;p&gt;I found the &lt;code&gt;combine-reducers&lt;/code&gt; function really interesting to study and reimplement in Clojure. I have not seen a similar function used in a Clojure context before.&lt;/p&gt;&lt;p&gt;I also find it amazing how essential functional programming has become to client side Javascript in 2016 with the rise of React and Redux (and others). I hope I've been able to show how functional programming ideas are at the very heart of how Redux works.&lt;/p&gt;
</description>
<pubDate>
Sat, 14 May 2016 00:00:00 +0300
</pubDate>
<author>
Jonas Enlund
</author>
</item>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/11-1-2015-pre-post-conditions.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/11-1-2015-pre-post-conditions.html
</link>
<title>
A note on pre and post conditions
</title>
<description>
&lt;p&gt;David Nolen recently published two interesting blog posts (&lt;a href='http://swannodette.github.io/2015/01/10/faster-validation-through-immutability/'&gt;here&lt;/a&gt; and  &lt;a href='http://swannodette.github.io/2015/01/09/life-with-dynamic-typing/'&gt;here&lt;/a&gt;) about the usefulness of pre and post conditions. I have recently started to use quite a lot of pre/post conditions (and other assertions and invariants) in my own code and found that they really help a lot during development. This is just a short note about how one of the examples David gave can be extended to check more known properties of the function under test.&lt;/p&gt;&lt;p&gt;Let's use the following distance function as the running example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn dist &amp;#91;p0 p1&amp;#93;
  &amp;#40;let &amp;#91;a &amp;#40;- &amp;#40;:x p0&amp;#41; &amp;#40;:x p1&amp;#41;&amp;#41;
        b &amp;#40;- &amp;#40;:y p0&amp;#41; &amp;#40;:y p1&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;js/Math.sqrt &amp;#40;+ &amp;#40;&amp;#42; a a&amp;#41;
                     &amp;#40;&amp;#42; b b&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;David showed how to add &lt;strong&gt;pre conditions&lt;/strong&gt; to this function in order to do runtime type checking:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn dist &amp;#91;p0 p1&amp;#93;
  {:pre &amp;#91;&amp;#40;point? p0&amp;#41; &amp;#40;point? p1&amp;#41;&amp;#93;}
  ...&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is really useful and will catch a lot bugs during development but pre and post conditions are not limited to only type checking. This example is especially illuminating since distance functions are &lt;a href='http://en.wikipedia.org/wiki/Metric&amp;#95;%28mathematics%29'&gt;well studied in mathematics&lt;/a&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;#40;dist p0 p1&amp;#41;&lt;/code&gt; = &lt;code&gt;0&lt;/code&gt; if and only if &lt;code&gt;&amp;#40;= p0 p1&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#40;dist p0 p1&amp;#41;&lt;/code&gt; &gt; &lt;code&gt;0&lt;/code&gt; if and only if &lt;code&gt;&amp;#40;not= p0 p1&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#40;dist p0 p1&amp;#41;&lt;/code&gt; = &lt;code&gt;&amp;#40;dist p1 p0&amp;#41;&lt;/code&gt; for all points &lt;code&gt;p0&lt;/code&gt; and &lt;code&gt;p1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#40;dist p0 p1&amp;#41;&lt;/code&gt; + &lt;code&gt;&amp;#40;dist p1 p2&amp;#41;&lt;/code&gt; &gt;= &lt;code&gt;&amp;#40;dist p0 p2&amp;#41;&lt;/code&gt; for all points &lt;code&gt;p0&lt;/code&gt;, &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It should be quite obvious that checking the types of the input arguments has nothing to do with whether the above properties hold or not. The first two properties however lend themselves well as a post condition:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn dist &amp;#91;p0 p1&amp;#93;
  {:pre &amp;#91;&amp;#40;point? p0&amp;#41; &amp;#40;point? p1&amp;#41;&amp;#93;
   :post &amp;#91;&amp;#40;if &amp;#40;= p0 p1&amp;#41;
            &amp;#40;zero? %&amp;#41;
            &amp;#40;pos? %&amp;#41;&amp;#41;&amp;#93;}
  ...&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that &lt;code&gt;%&lt;/code&gt; is bound to the functions return value. The expression &lt;code&gt;&amp;#40;if &amp;#40;= p0 p1&amp;#41; &amp;#40;zero? %&amp;#41; &amp;#40;pos? %&amp;#41;&amp;#41;&lt;/code&gt; completely captures the first two properties of our metric function and nicely ties the input arguments to the output without having to do the actual calculation (which could introduce its own set of bugs).&lt;/p&gt;&lt;p&gt;The last two properties doesn't lend themselves well to pre / post conditions and are therefor better handled by external testing tools. One obvious choice in this particular case is to use &lt;a href='https://github.com/clojure/test.check'&gt;test.check&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def commutativity
  &amp;#40;prop/for-all &amp;#91;p0 &amp;#40;gen-point&amp;#41;
                 p1 &amp;#40;gen-point&amp;#41;&amp;#93;
    &amp;#40;almost= &amp;#40;dist p0 p1&amp;#41; &amp;#40;dist p1 p0&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def triangle-inequality
  &amp;#40;prop/for-all &amp;#91;p0 &amp;#40;gen-point&amp;#41;
                 p1 &amp;#40;gen-point&amp;#41;
                 p2 &amp;#40;gen-point&amp;#41;&amp;#93;
    &amp;#40;&amp;gt;= &amp;#40;+ &amp;#40;dist p0 p1&amp;#41; &amp;#40;dist p1 p2&amp;#41;&amp;#41;
        &amp;#40;dist p0 p2&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All tools that help us create reliable software should be carefully evaluated and used when appropriate. I'm happy to have put pre/post in my own toolbelt.&lt;/p&gt;
</description>
<pubDate>
Sun, 11 Jan 2015 00:00:00 +0200
</pubDate>
<author>
Jonas Enlund
</author>
</item>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/14-12-2014-controlled-input.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/14-12-2014-controlled-input.html
</link>
<title>
Controlled and Uncontrolled input
</title>
<description>
&lt;p&gt;&lt;a href='http://facebook.github.io/react/'&gt;React&lt;/a&gt; tries as much as possible to be &lt;em&gt;declarative&lt;/em&gt;: The body of the &lt;code&gt;render&lt;/code&gt; method is a description of the component &lt;em&gt;at any point in time&lt;/em&gt;. Some input elements pose an interesting challange to this problem:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; value={this.props.name} onChange=... /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given that we specify that the value of the input is &lt;code&gt;this.props.value&lt;/code&gt;, and props are treated immutably by react, what should happen if we type something into the input box? If we change the content of the input we break the declarative model of React because the specified value does not match the actual content.&lt;/p&gt;&lt;p&gt;In React parlance, there is a difference between &lt;a href='http://facebook.github.io/react/docs/forms.html#controlled-components'&gt;controlled and uncontrolled components&lt;/a&gt;. A controlled component will always contain the value specified in the &lt;code&gt;value&lt;/code&gt; attribute. Controlled components are preferred because they preserve the overall declarative nature of React. The &lt;code&gt;onChange&lt;/code&gt; callback must somehow cause a re-render so that the value property can be updated:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var NameInput = React.createClass&amp;#40;{
  render: function&amp;#40;&amp;#41; {
    return &amp;#40;
      &amp;lt;input type=&amp;quot;text&amp;quot;
             value={this.props.name.toUpperCase&amp;#40;&amp;#41;}
             onChange={this.handleChange}/&amp;gt;
    &amp;#41;;
  },

  handleChange: function&amp;#40;evt&amp;#41; {
    this.props.nameChange&amp;#40;evt.target.value&amp;#41;;
  }
}&amp;#41;;

var SomeForm = React.createClass&amp;#40;{
  getInitialState: function&amp;#40;&amp;#41; {
    return {name: &amp;quot;&amp;quot;,
            age: &amp;quot;&amp;quot;};
  },

  render: function&amp;#40;&amp;#41; {
    return &amp;#40;
      &amp;lt;ul&amp;gt;
       &amp;lt;li&amp;gt;Name: &amp;lt;NameInput name={this.state.name}
                            nameChange={this.handleNameChange}/&amp;gt;&amp;lt;/li&amp;gt;
       &amp;lt;li&amp;gt;Age: ...&amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;#41;;
  },

  handleNameChange: function&amp;#40;name&amp;#41; {
    this.setState&amp;#40;{name: name}&amp;#41;;
  }
}&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the &lt;code&gt;NameInput&lt;/code&gt; component is completely stateless. At any point in time, the component will display the value of &lt;code&gt;this.props.name.toUpperCase&amp;#40;&amp;#41;&lt;/code&gt;. It is up to the &lt;code&gt;onChange&lt;/code&gt; callback to decide what to do if the user types something into the box. There is no default behaviour like &lt;em&gt;&quot;add the typed letter at cursor position&quot;&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;React also has a concept of uncontrolled components where instead of specifying &lt;code&gt;value&lt;/code&gt; you use &lt;code&gt;defaultValue&lt;/code&gt; and this value will be used for the initial render and after that the textbox behaves like a standard html input element. Note that uncontrolled components breaks the declarativeness. The words &lt;em&gt;&quot;initial render&quot;&lt;/em&gt; and &lt;em&gt;&quot;after&quot;&lt;/em&gt; should make it clear that the render function no longer specifies how the component should render at any point in time.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;input&amp;#95;components&amp;#95;in&amp;#95;om&quot;&gt;&lt;/a&gt;Input components in Om&lt;/h3&gt;&lt;p&gt;While working with input elements in Om I was surprised to realize that my components did not behave like controlled components does in React. After some digging I realized that the behaviour seemed to be intentional, since &lt;a href='https://github.com/swannodette/om/blob/master/src/om/dom.cljs#L7-L36'&gt;Om wraps React input components in its own stateful versions&lt;/a&gt;. The reason for this is that Om does rendering asynchronously via &lt;code&gt;requestAnimationFrame&lt;/code&gt; and it turns out that React does not fully support this mode of rendering.&lt;/p&gt;&lt;p&gt;As an example, consider the following application:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def app-state &amp;#40;atom {:text &amp;quot;foo&amp;quot;}&amp;#41;&amp;#41;

&amp;#40;defn my-input &amp;#91;app&amp;#93;
  &amp;#40;reify
    om/IRender
    &amp;#40;render &amp;#91;this&amp;#93;
      &amp;#40;dom/input
        #js {:type &amp;quot;text&amp;quot;
             :value &amp;#40;.toUpperCase &amp;#40;:text app&amp;#41;&amp;#41;
             :onChange #&amp;#40;if &amp;#40;&amp;lt; &amp;#40;count app&amp;#41; 10&amp;#41;
                          &amp;#40;om/transact! app
                                        :text
                                        &amp;#40;constantly &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;om/root
  my-input
  app-state
  {:target &amp;#40;. js/document &amp;#40;getElementById &amp;quot;app&amp;quot;&amp;#41;&amp;#41;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you try to run this application you will notice two interesting things&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The input text is kept in upper case. However, if you try to add a character to the middle of the text the cursor will jump to the last position. If there is no transformation done (i.e., &lt;code&gt;:value &amp;#40;:text app&amp;#41;&lt;/code&gt; instead of &lt;code&gt;:value &amp;#40;.toUpperCase &amp;#40;:text app&amp;#41;&amp;#41;&lt;/code&gt;) the cursor will stay at the correct position.&lt;/li&gt;&lt;li&gt;The app-state is updated only if the text is less that 10 characters long. It is still possible to type more characters into the input box and in that case &lt;em&gt;the local state of the component differs from the application state&lt;/em&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;a name=&quot;input&amp;#95;components&amp;#95;in&amp;#95;reagent&quot;&gt;&lt;/a&gt;Input components in Reagent&lt;/h3&gt;&lt;p&gt;Reagent also does asynchronous rendering and as such should be battling with the same issues, and indeed &lt;a href='https://github.com/reagent-project/reagent/blob/master/src/reagent/impl/template.cljs#L82-L140'&gt;it does&lt;/a&gt;. I have not yet been able to completely understand this implementation but it seems like an attempt to keep the semantics of Reacts controlled components even in the case of asynchronous rendering.&lt;/p&gt;&lt;p&gt;It seems like this is not an easy task. For example, if you try this short reagent code snippet (which is very similar to the Om example above)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn my-input &amp;#91;on-change text&amp;#93;
  &amp;#91;:div &amp;#91;:input {:type &amp;quot;text&amp;quot;
                 :value &amp;#40;.toUpperCase text&amp;#41;
                 :on-change #&amp;#40;if &amp;#40;&amp;lt; &amp;#40;count text&amp;#41; 10&amp;#41;
                               &amp;#40;on-change &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def text &amp;#40;reagent/atom &amp;quot;foo&amp;quot;&amp;#41;&amp;#41;

&amp;#40;defn main-page &amp;#91;&amp;#93;
  &amp;#91;my-input #&amp;#40;reset! text %&amp;#41; @text&amp;#93;&amp;#41;

&amp;#40;defn init! &amp;#91;&amp;#93;
  &amp;#40;reagent/render-component &amp;#91;main-page&amp;#93; &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;You will notice the same behaviour as in the Om example: If you type a character in the middle of the text the cursor jumps to the last position.&lt;/li&gt;&lt;li&gt;The state of the &lt;code&gt;text&lt;/code&gt; atom and the rendered text in the component seems to be kept in sync since it is not possible to type more than 10 characters into the input box.&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;a name=&quot;conclusions&quot;&gt;&lt;/a&gt;Conclusions&lt;/h3&gt;&lt;p&gt;It is unfortunate that asynchronous rendering does not work properly in React. However, this is hardly the fault of React, since they are pretty clear in their communication with the community that rendering with &lt;code&gt;requestAnimationFrame&lt;/code&gt; is simply &lt;a href='https://groups.google.com/forum/#!msg/reactjs/LkTihnf6Ey8/FgFvvf33GckJ'&gt;not supported&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Let me repeat myself: rAF batching is not supported. It is not a priority for us because it does not solve any real problems that I know of and makes things much harder to reason about. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;It is interesting that the various Clojurescript React wrappers choose async rendering as their model when the underlying library that they rely on does not fully support it.&lt;/p&gt;
</description>
<pubDate>
Sun, 14 Dec 2014 00:00:00 +0200
</pubDate>
<author>
Jonas Enlund
</author>
</item>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/7-12-2014-om-table.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/7-12-2014-om-table.html
</link>
<title>
Reusable Om components, part 2
</title>
<description>
&lt;p&gt;In &lt;a href='http://jonase.github.io/nil-recur/posts/29-11-2014-om-select.html'&gt;part 1&lt;/a&gt; of this series we built a declarative &lt;code&gt;select&lt;/code&gt; component. In this post we will instead build a &lt;code&gt;table&lt;/code&gt; component. We take the same approach but along the way we will find a few interesting limitations and gotchas.&lt;/p&gt;&lt;p&gt;Let's start the same way as in the previous installment, but this time we'll use a different data set:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def posts
  &amp;#91;{:project &amp;quot;Reagent&amp;quot;
    :author &amp;quot;holmsand&amp;quot;
    :url &amp;quot;https://github.com/reagent-project/reagent&amp;quot;}
   {:project &amp;quot;Quiescent&amp;quot;
    :author &amp;quot;levand&amp;quot;
    :url &amp;quot;https://github.com/levand/quiescent&amp;quot;}
   {:project &amp;quot;Reacl&amp;quot;
    :author &amp;quot;active-group&amp;quot;
    :url &amp;quot;https://github.com/active-group/reacl&amp;quot;}
   {:project &amp;quot;Om&amp;quot;
    :author &amp;quot;swannodette&amp;quot;
    :url &amp;quot;https://github.com/swannodette/om&amp;quot;}&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The table component we'll build will be used as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;om/build table
          {:data projects
           :columns &amp;#91;{:title &amp;quot;Author&amp;quot;
                      :cell-fn :author}
                     {:title &amp;quot;Project&amp;quot;
                      :cell-fn &amp;#40;fn &amp;#91;{:keys &amp;#91;project url&amp;#93;
                                 &amp;#40;dom/a #js {:href url} project&amp;#41;}


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I hope the above is self-explanatory (at least that's the goal). In particular, the &lt;code&gt;:columns&lt;/code&gt; vector is a &lt;strong&gt;declerative description&lt;/strong&gt; of the table columns. The &lt;code&gt;cell-fn&lt;/code&gt; takes a record and returns something that should be rendered. For &quot;Author&quot; the &lt;code&gt;cell-fn&lt;/code&gt; simply returns a string and for the &quot;Project&quot; an anchor tag is returned.&lt;/p&gt;&lt;p&gt;The table component as described above will work fine until you need to render another component in the cells of a column. For example, say you have created a component &lt;code&gt;voter&lt;/code&gt; which you would like to use to vote on the individual projects:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn voter &amp;#91;{:keys &amp;#91;votes on-vote&amp;#93;} owner&amp;#93;
  &amp;#40;om/component
   &amp;#40;dom/span nil
             &amp;#40;dom/button #js {:onClick #&amp;#40;on-vote &amp;#40;inc votes&amp;#41;&amp;#41;} &amp;quot;+&amp;quot;&amp;#41;
             votes
             &amp;#40;dom/button #js {:onClick #&amp;#40;on-vote &amp;#40;dec votes&amp;#41;&amp;#41;} &amp;quot;-&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;voter&lt;/code&gt; function is an Om component and we should be able to render it in our table. Let's extend the &lt;code&gt;:columns&lt;/code&gt; description with an &lt;code&gt;:cell&lt;/code&gt; key:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;om/build table
          {:data projects
           :columns &amp;#91;{:title &amp;quot;Votes&amp;quot;
                      :cell voter
                      :cell-data-fn &amp;#40;fn &amp;#91;record&amp;#93;
                                      {:votes &amp;lt;number-of-votes&amp;gt;
                                       :on-vote &amp;lt;on-vote-callback&amp;gt;}&amp;#41;
                     {:title &amp;quot;Author&amp;quot;
                      :cell-fn :author}
                     {:title &amp;quot;Project&amp;quot;
                      :cell-fn &amp;#40;fn &amp;#91;{:keys &amp;#91;project url&amp;#93;
                                 &amp;#40;dom/a #js {:href url} project&amp;#41;}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that we also need a &lt;code&gt;:cell-data-fn&lt;/code&gt; key that, given a record returns the data that the &lt;code&gt;cell&lt;/code&gt; component needs. In the implementation you will see that &lt;code&gt;:cell-data-fn&lt;/code&gt; defaults to &lt;code&gt;identity&lt;/code&gt; since it's often the case that the component only needs the actual record.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;all&amp;#95;the&amp;#95;things&amp;#95;that&amp;#95;won't&amp;#95;work&quot;&gt;&lt;/a&gt;All the things that won't work&lt;/h3&gt;&lt;p&gt;For me, the biggest limitation of Om is the lack of support for anonymous and higher order components. For example, it would be great if we wouldn't need both &lt;code&gt;:cell&lt;/code&gt; and &lt;code&gt;:cell-fn&lt;/code&gt; and for simple cases would be able to write&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;om/build table
          {:data projects
           :columns &amp;#91;{:title &amp;quot;Project&amp;quot;
                      :cell #&amp;#40;om/component &amp;#40;dom/a #js {:href &amp;#40;:url %&amp;#41;} &amp;#40;:name %&amp;#41;&amp;#41;&amp;#41;}
                     ...&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above will appear to work, but it does not do what you might expect. A new component (for each record in this case) is created and mounted each time the parent component is rendered! The same story again with higher order components:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn text-component &amp;#91;key&amp;#93;
  &amp;#40;fn &amp;#91;data &amp;#95;&amp;#93;
    &amp;#40;om/component
      &amp;#40;span nil &amp;#40;key data&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;om/build table
          {:data projects
           :columns &amp;#91;{:title &amp;quot;Author&amp;quot;
                      :cell &amp;#40;text-component :author&amp;#41;}
                     ...&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same problem appears here. A new component is created and mounted on each re-render. It might appear to work fine until, for example, you start to loose focus on input elements or experience performance problems.&lt;/p&gt;&lt;p&gt;I'd love to hear from the other Clojurescript React wrappers out there (reagent, quiescent etc.) if they have found any solutions for these problems. It's my understanding however that React itself has this same limitation and is therefor a fundamental problem which is difficult to get away from (I would be extremely happy to be proven wrong on this issue!). Unfortunately, this means that one of the most powerful abstraction mechanisms in functional programming (= &lt;em&gt;closures&lt;/em&gt;) are not available to component authors.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;example&amp;#95;application&quot;&gt;&lt;/a&gt;Example application&lt;/h3&gt;&lt;p&gt;Here's a very simple example application using (and implementing) the &lt;code&gt;table&lt;/code&gt; component which sorts the table based on the votes:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;;; table component

&amp;#40;defn table-header &amp;#91;columns owner&amp;#93;
  &amp;#40;om/component
   &amp;#40;dom/thead nil
              &amp;#40;apply dom/tr nil
                     &amp;#40;map #&amp;#40;dom/th nil &amp;#40;:title %&amp;#41;&amp;#41;
                          columns&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn table-body &amp;#91;{:keys &amp;#91;data columns&amp;#93;} owner&amp;#93;
  &amp;#40;om/component
   &amp;#40;apply dom/tbody nil
     &amp;#40;for &amp;#91;record data&amp;#93;
       &amp;#40;apply dom/tr nil
         &amp;#40;for &amp;#91;{:keys &amp;#91;cell-fn cell cell-data-fn&amp;#93;} columns&amp;#93;
           &amp;#40;dom/td nil
             &amp;#40;if cell-fn
               &amp;#40;cell-fn record&amp;#41;
               &amp;#40;om/build cell &amp;#40;&amp;#40;or cell-data-fn identity&amp;#41; record&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn table &amp;#91;table-spec owner&amp;#93;
  &amp;#40;om/component
   &amp;#40;dom/table nil
              &amp;#40;om/build table-header &amp;#40;:columns table-spec&amp;#41;&amp;#41;
              &amp;#40;om/build table-body table-spec&amp;#41;&amp;#41;&amp;#41;&amp;#41;


;;; Application

&amp;#40;defn index-by &amp;#91;f coll&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;result item&amp;#93;
            &amp;#40;assoc result &amp;#40;f item&amp;#41; item&amp;#41;&amp;#41;
          {}
          coll&amp;#41;&amp;#41;

&amp;#40;def app-state &amp;#40;atom &amp;#40;index-by :name projects&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn voter &amp;#91;{:keys &amp;#91;votes on-vote&amp;#93;} owner&amp;#93;
  &amp;#40;om/component
   &amp;#40;dom/span nil
             &amp;#40;dom/button #js {:onClick #&amp;#40;on-vote &amp;#40;inc votes&amp;#41;&amp;#41;} &amp;quot;+&amp;quot;&amp;#41;
             votes
             &amp;#40;dom/button #js {:onClick #&amp;#40;on-vote &amp;#40;dec votes&amp;#41;&amp;#41;} &amp;quot;-&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn root-component &amp;#91;data&amp;#93;
  &amp;#40;om/component
   &amp;#40;let &amp;#91;data &amp;#40;om/value data&amp;#41;&amp;#93;
     &amp;#40;om/build table
               {:data &amp;#40;-&amp;gt;&amp;gt; data
                           om/value
                           vals
                           &amp;#40;sort-by #&amp;#40;or &amp;#40;:votes %&amp;#41; 0&amp;#41;&amp;#41;
                           reverse&amp;#41;
                :columns &amp;#91;{:title &amp;quot;Votes&amp;quot;
                           :cell voter
                           :cell-data-fn &amp;#40;fn &amp;#91;record&amp;#93;
                                           {:votes &amp;#40;or &amp;#40;:votes record&amp;#41; 0&amp;#41;
                                            :on-vote &amp;#40;fn &amp;#91;n&amp;#93;
                                                       &amp;#40;swap! app-state
                                                              assoc-in
                                                              &amp;#91;&amp;#40;:name record&amp;#41; :votes&amp;#93;
                                                              n&amp;#41;&amp;#41;}&amp;#41;}
                          {:title &amp;quot;Author&amp;quot;
                           :cell-fn :author}
                          {:title &amp;quot;Project&amp;quot;
                           :cell-fn &amp;#40;fn &amp;#91;{:keys &amp;#91;name url&amp;#93;}&amp;#93;
                                      &amp;#40;dom/a #js {:href url} name&amp;#41;&amp;#41;}&amp;#93;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn init &amp;#91;&amp;#93;
  &amp;#40;om/root root-component
           app-state
           {:target &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to run the application you can clone the &lt;a href='https://github.com/jonase/nil-recur'&gt;nil-recur&lt;/a&gt; repo where you can find &lt;a href='https://github.com/jonase/nil-recur/blob/master/examples/src/examples/table&amp;#95;component.cljs'&gt;this example&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Sun, 07 Dec 2014 00:00:00 +0200
</pubDate>
<author>
Jonas Enlund
</author>
</item>
<item>
<guid>
http://jonase.github.io/nil-recur/posts/29-11-2014-om-select.html
</guid>
<link>
http://jonase.github.io/nil-recur/posts/29-11-2014-om-select.html
</link>
<title>
Reusable Om components, part 1
</title>
<description>
&lt;p&gt;This post is (hopefully) the first in a series on posts on how to create reusable components in Om. I will describe a simple declarative &lt;code&gt;select&lt;/code&gt; component and the rationale behind wrapping such a trivial html element in an Om component. It assumes basic familiarity with Clojurescript and Om.&lt;/p&gt;&lt;p&gt;The running example will be rendering an input where the data source is a set of &lt;em&gt;users&lt;/em&gt;, in this case the following set of distinguished computer scientists:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def users
  &amp;#91;{:first-name &amp;quot;Donald&amp;quot; :last-name &amp;quot;Knuth&amp;quot; :email &amp;quot;donald-knuth@example.com&amp;quot;}
   {:first-name &amp;quot;Leslie&amp;quot; :last-name &amp;quot;Lamport&amp;quot; :email &amp;quot;leslie-lamport@example.com&amp;quot;}
   {:first-name &amp;quot;Edsger&amp;quot; :last-name &amp;quot;Dijkstra&amp;quot; :email &amp;quot;edsger-dijskstra@example.com&amp;quot;}
   {:first-name &amp;quot;John&amp;quot; :last-name &amp;quot;McCarthy&amp;quot; :email &amp;quot;john-mccarthy@example.com&amp;quot;}
   {:first-name &amp;quot;Alan&amp;quot; :last-name &amp;quot;Kay&amp;quot; :email &amp;quot;alan-kay@example.com&amp;quot;}&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Imagine we're inside a component and wish to render a standard html &lt;code&gt;select&lt;/code&gt; element populated with the above data. It would probably look something like this in pure Om:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;apply dom/select #js {:onChange on-user-selected
                       :value &amp;#40;or selected-user-id &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;&amp;#41;}
       &amp;#40;when-not selected
         &amp;#40;dom/option #js {:disabled true :value &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;}
                     &amp;quot;Select a user&amp;quot;&amp;#41;&amp;#41;
       &amp;#40;map &amp;#40;fn &amp;#91;{:keys &amp;#91;first-name last-name email&amp;#93;}&amp;#93;
              &amp;#40;dom/option #js {:value email}
                          last-name &amp;quot;, &amp;quot; first-name&amp;#41;&amp;#41;
            users&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This isn't too bad, but let's focus on a few possible problems:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We need to build each option manually.&lt;/li&gt;&lt;li&gt;We need to choose (or construct) a suitable unique string to use as  the &lt;code&gt;value&lt;/code&gt; property for each option tag and we need to be able to  generate matching values for the currently selected record.&lt;/li&gt;&lt;li&gt;The argument to the &lt;code&gt;onChange&lt;/code&gt; callback function will be an &lt;code&gt;Event&lt;/code&gt;  object. We need to look up the selected record separately.&lt;/li&gt;&lt;li&gt;Extra logic needs to be implemented each time a &lt;code&gt;select&lt;/code&gt; is  needed. In this example we render a disabled &lt;code&gt;placeholder&lt;/code&gt; option if  no user is selected.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I consider all these points to be incidental complexity. Of course, it's possible to cut away some of the Om boilerplate by using either &lt;a href='https://github.com/r0man/sablono'&gt;sablono&lt;/a&gt; or &lt;a href='https://github.com/Prismatic/om-tools'&gt;om-tools&lt;/a&gt;. With sablono the equivalent code would be&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;:select {:on-change on-user-selected
          :value &amp;#40;or selected-user-id &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;&amp;#41;}
 &amp;#40;when-not selected
   &amp;#91;:option {:disabled true :value &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;} &amp;quot;Select a user&amp;quot;&amp;#93;&amp;#41;
 &amp;#40;map &amp;#40;fn &amp;#91;{:keys &amp;#91;first-name last-name email&amp;#93;}&amp;#93;
        &amp;#91;:option {:value email} last-name &amp;quot;, &amp;quot; first-name&amp;#93;&amp;#41;
      users&amp;#41;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you hopefully realize, the above code snippet is a bit shorter and perhaps easier to read but the issues raised above are still the same. You can make the complexity more concise, but you can't remove it with these tools alone.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;an&amp;#95;alternative&amp;#95;&lt;code&gt;select&lt;/code&gt;&amp;#95;component&quot;&gt;&lt;/a&gt;An alternative &lt;code&gt;select&lt;/code&gt; component&lt;/h3&gt;&lt;p&gt;Next we will build a component without the incidental complexities mentioned above. The component, once implemented, will be used as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;om/build select
          {:placeholder &amp;quot;Select a user&amp;quot;
           :selected selected-user
           :data users
           :label-fn #&amp;#40;str &amp;#40;:last-name %&amp;#41; &amp;quot;, &amp;quot; &amp;#40;:first-name %&amp;#41;&amp;#41;
           :key-fn :email
           :on-select on-user-selected}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;:placeholder&lt;/code&gt; is optional and used if no record is selected.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:selected&lt;/code&gt; is the selected record or &lt;code&gt;nil&lt;/code&gt; if none is selected.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:data&lt;/code&gt; is a sequence of records.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:label-fn&lt;/code&gt; is a function which takes a record and returns a string  to be used as the option label.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:key-fn&lt;/code&gt; is a function which should return a unique string for each  record.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:on-select&lt;/code&gt; is a callback function where the function argument is  the selected record as opposed to an &lt;code&gt;Event&lt;/code&gt; object.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This component is easy to read and write, declerative and reusable. The implementation of the &lt;code&gt;select&lt;/code&gt; component is not too complex either:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn select &amp;#91;{:keys &amp;#91;placeholder data selected label-fn key-fn on-select&amp;#93;} owner&amp;#93;
  &amp;#40;reify
    om/IRender
    &amp;#40;render &amp;#91;this&amp;#93;
      &amp;#40;apply dom/select
             #js {:onChange &amp;#40;fn &amp;#91;evt&amp;#93;
                              &amp;#40;let &amp;#91;key &amp;#40;-&amp;gt; evt .-target .-value&amp;#41;
                                    sel &amp;#40;some &amp;#40;fn &amp;#91;record&amp;#93;
                                                &amp;#40;if &amp;#40;= key &amp;#40;key-fn record&amp;#41;&amp;#41;
                                                  record&amp;#41;&amp;#41;
                                              data&amp;#41;&amp;#93;
                                &amp;#40;on-select sel&amp;#41;&amp;#41;&amp;#41;
                  :value &amp;#40;if selected
                           &amp;#40;key-fn selected&amp;#41;
                           &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;&amp;#41;}
             &amp;#40;when &amp;#40;and placeholder &amp;#40;not selected&amp;#41;&amp;#41;
               &amp;#40;dom/option #js {:disabled true :value &amp;quot;&amp;#95;&amp;#95;placeholder&amp;quot;} placeholder&amp;#41;&amp;#41;
             &amp;#40;map &amp;#40;fn &amp;#91;record&amp;#93;
                    &amp;#40;dom/option #js {:value &amp;#40;key-fn record&amp;#41;} &amp;#40;label-fn record&amp;#41;&amp;#41;&amp;#41;
                  data&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When working with Om I strive to create components like this. I've found that these stateless and declarative components are the most reliable and reusable. In addition, they work very well with how Om takes advantage of immutable data structures in order to avoid unnecessary rendering.&lt;/p&gt;&lt;p&gt;If you want to build and run these examples on your own, complete examples are available in the &lt;a href='https://github.com/jonase/nil-recur/blob/master/examples/src/examples/select&amp;#95;component.cljs'&gt;nil/recur&lt;/a&gt; github repo.&lt;/p&gt;
</description>
<pubDate>
Sat, 29 Nov 2014 00:00:00 +0200
</pubDate>
<author>
Jonas Enlund
</author>
</item>
</channel>
</rss>
