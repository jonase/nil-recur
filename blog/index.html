<html>
  <head>
    <meta charset="utf-8"/>
    <title>nil/recur</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="css/screen.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <h1><a class="navbar-brand" href="/blog/index.html">nil/recur</a></h1>
        </div>
        <!-- nav links -->
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li  class="active" ><a href="/blog/index.html">Home</a></li>
            <li ><a href="/blog/archives.html">Archives</a></li>
            
            <li >
              <a href="/blog/pages/about.html">About</a>
            </li>
            
            <li><a href="/blog/feed.xml">RSS</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div id="wrapper" class="container">
      <div class="row">
        <div class="col-md-8">
          <div id="content">
            
<div id="post">
    <div id="post-header">
        <h2>Reusable Om components, part 1</h2>
        <p class="date">November 29, 2014</p>
    </div>
    <div>
        
        <p>This post is (hopefully) the first in a series on posts on how to create reusable components in Om. I will describe a simple declarative <code>select</code> component and the rationale behind wrapping such a trivial html element in an Om component. It assumes basic familiarity with Clojurescript and Om.</p><p>The running example will be rendering an input where the data source is a set of <em>users</em>, in this case the following set of distinguished computer scientists:</p><pre><code>&#40;def users
  &#91;{:first-name &quot;Donald&quot; :last-name &quot;Knuth&quot; :email &quot;donald-knuth@example.com&quot;}
   {:first-name &quot;Leslie&quot; :last-name &quot;Lamport&quot; :email &quot;leslie-lamport@example.com&quot;}
   {:first-name &quot;Edsger&quot; :last-name &quot;Dijkstra&quot; :email &quot;edsger-dijskstra@example.com&quot;}
   {:first-name &quot;John&quot; :last-name &quot;McCarthy&quot; :email &quot;john-mccarthy@example.com&quot;}
   {:first-name &quot;Alan&quot; :last-name &quot;Kay&quot; :email &quot;alan-kay@example.com&quot;}&#93;&#41;
</code></pre><p>Imagine we're inside a component and wish to render a standard html <code>select</code> element populated with the above data. It would probably look something like this in pure Om:</p><pre><code>&#40;apply dom/select #js {:onChange on-user-selected
                       :value &#40;or selected-user-id &quot;&#95;&#95;placeholder&quot;&#41;}
       &#40;when-not selected
         &#40;dom/option #js {:disabled true :value &quot;&#95;&#95;placeholder&quot;}
                     &quot;Select a user&quot;&#41;&#41;
       &#40;map &#40;fn &#91;{:keys &#91;first-name last-name email&#93;}&#93;
              &#40;dom/option #js {:value email}
                          last-name &quot;, &quot; first-name&#41;&#41;
            users&#41;&#41;
</code></pre><p>This isn't too bad, but let's focus on a few possible problems:</p><ul><li>We need to build each option manually.</li><li>We need to choose (or construct) a suitable unique string to use as  the <code>value</code> property for each option tag and we need to be able to  generate matching values for the currently selected record.</li><li>The argument to the <code>onChange</code> callback function will be an <code>Event</code>  object. We need to look up the selected record separately.</li><li>Extra logic needs to be implemented each time a <code>select</code> is  needed. In this example we render a disabled <code>placeholder</code> option if  no user is selected.</li></ul><p>I consider all these points to be incidental complexity. Of course, it's possible to cut away some of the Om boilerplate by using either <a href='https://github.com/r0man/sablono'>sablono</a> or <a href='https://github.com/Prismatic/om-tools'>om-tools</a>. With sablono the equivalent code would be</p><pre><code>&#91;:select {:on-change on-user-selected
          :value &#40;or selected-user-id &quot;&#95;&#95;placeholder&quot;&#41;}
 &#40;when-not selected
   &#91;:option {:disabled true :value &quot;&#95;&#95;placeholder&quot;} &quot;Select a user&quot;&#93;&#41;
 &#40;map &#40;fn &#91;{:keys &#91;first-name last-name email&#93;}&#93;
        &#91;:option {:value email} last-name &quot;, &quot; first-name&#93;&#41;
      users&#41;&#93;
</code></pre><p>As you hopefully realize, the above code snippet is a bit shorter and perhaps easier to read but the issues raised above are still the same. You can make the complexity more concise, but you can't remove it with these tools alone.</p><h3><a name="an&#95;alternative&#95;<code>select</code>&#95;component"></a>An alternative <code>select</code> component</h3><p>Next we will build a component without the incidental complexities mentioned above. The component, once implemented, will be used as follows:</p><pre><code>&#40;om/build select
          {:placeholder &quot;Select a user&quot;
           :selected selected-user
           :data users
           :label-fn #&#40;str &#40;:last-name %&#41; &quot;, &quot; &#40;:first-name %&#41;&#41;
           :key-fn :email
           :on-select on-user-selected}&#41;
</code></pre><ul><li><code>:placeholder</code> is optional and used if no record is selected.</li><li><code>:selected</code> is the selected record or <code>nil</code> if none is selected.</li><li><code>:data</code> is a sequence of records.</li><li><code>:label-fn</code> is a function which takes a record and returns a string  to be used as the option label.</li><li><code>:key-fn</code> is a function which should return a unique string for each  record.</li><li><code>:on-select</code> is a callback function where the function argument is  the selected record as opposed to an <code>Event</code> object.</li></ul><p>This component is easy to read and write, declerative and reusable. The implementation of the <code>select</code> component is not too complex either:</p><pre><code>&#40;defn select &#91;{:keys &#91;placeholder data selected label-fn key-fn on-select&#93;} owner&#93;
  &#40;reify
    om/IRender
    &#40;render &#91;this&#93;
      &#40;apply dom/select
             #js {:onChange &#40;fn &#91;evt&#93;
                              &#40;let &#91;key &#40;-&gt; evt .-target .-value&#41;
                                    sel &#40;some &#40;fn &#91;record&#93;
                                                &#40;if &#40;= key &#40;key-fn record&#41;&#41;
                                                  record&#41;&#41;
                                              data&#41;&#93;
                                &#40;on-select sel&#41;&#41;&#41;
                  :value &#40;if selected
                           &#40;key-fn selected&#41;
                           &quot;&#95;&#95;placeholder&quot;&#41;}
             &#40;when &#40;and placeholder &#40;not selected&#41;&#41;
               &#40;dom/option #js {:disabled true :value &quot;&#95;&#95;placeholder&quot;} placeholder&#41;&#41;
             &#40;map &#40;fn &#91;record&#93;
                    &#40;dom/option #js {:value &#40;key-fn record&#41;} &#40;label-fn record&#41;&#41;&#41;
                  data&#41;&#41;&#41;&#41;&#41;
</code></pre><p>When working with Om I strive to create components like this. I've found that these stateless and declarative components are the most reliable and reusable. In addition, they work very well with how Om takes advantage of immutable data structures in order to avoid unnecessary rendering.</p><p>If you want to build and run these examples on your own, complete examples are available in the <a href='https://github.com/jonase/nil-recur/examples'>nil/recur</a> github repo.</p>
    </div>
    
    <div id="tags">
        <b>Tags: </b>
        
        <a href="/blog/tags/om.html">om</a>
        
        <a href="/blog/tags/clojurescript.html">clojurescript</a>
        
    </div>
    
    

    <div id="prev-next">
        
        
        
    </div>
</div>

          </div>
        </div>

        <div class="col-md-3">
          <div id="sidebar">
            <h3>Links</h3>
            <ul id="links">
              <li><a href="https://github.com/jonase">My Github</a></li>
              <li><a href="https://twitter.com/jonasenlund">Twitter</a></li>
              
            </ul>
            <div id="recent">
              <h3>Recent Posts</h3>
              <ul>
                
                <li><a href="/blog/posts/29-11-2014-om-select.html">Reusable Om components, part 1</a></li>
                
              </ul>
            </div>
            <div id="tags">
              <h3>Tags</h3>
              <ul>
                
                <li><a href="/blog/tags/clojurescript.html">clojurescript</a></li>
                
                <li><a href="/blog/tags/om.html">om</a></li>
                
              </ul>
            </div>
          </div>
        </div>
      </div>
      <footer>Copyright &copy; 2014 Jonas Enlund
        <p style="text-align: center;">
          Powered by <a href="https://github.com/lacarmen/cryogen">Cryogen</a>
        </p>
      </footer>
    </div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
